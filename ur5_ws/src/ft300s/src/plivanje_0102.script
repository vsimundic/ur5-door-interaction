def plivanje_0102():
  set_gravity([0.0, 0.0, 9.82])
  set_tool_voltage(0)
  set_safety_mode_transition_hardness(1)
  set_tcp(p[0.0,0.0,0.0,0.0,0.0,0.0])
  set_payload(3.0, [0.002, -0.004, 0.111])
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  step_count_b169bec4_7344_447b_b5fb_c11424a158d3 = 0.0
  thread Step_Counter_Thread_7fe1349e_5714_4705_86e4_0cb3478bec10():
    while (True):
      step_count_b169bec4_7344_447b_b5fb_c11424a158d3 = step_count_b169bec4_7344_447b_b5fb_c11424a158d3 + 1.0
      sync()
    end
  end
  run Step_Counter_Thread_7fe1349e_5714_4705_86e4_0cb3478bec10()
  # begin: URCap Installation Node
  #   Source: External Control, 1.0.4, FZI Research Center for Information Technology
  #   Type: External Control
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Copilot, 1.28.1.22634, Robotiq Inc.
  #   Type: Machine Tending
  def rq_is_stack_light_machine_state_idle():
  return False
  end
  def rq_is_stack_light_machine_state_running():
  return False
  end
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_3-Finger_Adaptive_Gripper, 1.0.1, Robotiq inc.
  #   Type: 3F Gripper
  modbus_delete_signal("gripper")
  modbus_add_signal("192.168.22.11",255,0,2,"gripper")
  modbus_set_signal_update_frequency("gripper", 10)
  # Robotiq inc.  2017
  
  ################################################################
  ## urcaps for the Robotiq's 3F Gripper
  ################################################################
  
  # aliases for the gripper output names
  # those values also represent offsets
  # in control registers
  rACT = 1
  rMOD = 2
  rGTO = 8
  rATR = 16
  rPOS = 3
  rFOR = 5
  rSPE = 11
  
  # aliases for the gripper input names
  # those values also represent offsets
  # in control registers
  gPRE = 1
  gACT = 8
  gMOD = 9
  gMOD1 = 9
  gMOD2 = 10
  gFLT = 19
  gFLT1 = 8
  gFLT2 = 9
  gFLT3 = 10
  gFLT4 = 11
  gGTO = 11
  gIMC = 12
  gIMC1 = 12
  gIMC2 = 13
  gSTA = 14
  gSTA1 = 14
  gSTA2 = 15
  
  #define modbus signal
  modbus_delete_signal("gripper_O0")
  modbus_delete_signal("gripper_O1")
  modbus_delete_signal("gripper_O2")
  modbus_delete_signal("gripper_I0")
  modbus_delete_signal("gripper_I1")
  
  
  modbus_add_signal("192.168.22.11",255,0,3,"gripper_O0")
  modbus_set_signal_update_frequency("gripper_O0", 10)
  modbus_add_signal("192.168.22.11",255,1,3,"gripper_O1")
  modbus_set_signal_update_frequency("gripper_O1", 10)
  modbus_add_signal("192.168.22.11",255,2,3,"gripper_O2")
  modbus_set_signal_update_frequency("gripper_O2", 10)
  modbus_add_signal("192.168.22.11",255,0,2,"gripper_I0")
  modbus_set_signal_update_frequency("gripper_I0", 10)
  modbus_add_signal("192.168.22.11",255,1,2,"gripper_I1")
  modbus_set_signal_update_frequency("gripper_I1", 10)
  modbus_set_runstate_dependent_choice("gripper_O0",0)
  modbus_set_runstate_dependent_choice("gripper_O1",0)
  modbus_set_runstate_dependent_choice("gripper_O2",0)
  
  
  
  
  # send the activation request to the gripper.
  def rq_activate():
  	rq_set_var(rACT,1)
  
      ACT = rq_get_var(gACT)
      while (ACT != 1):
          ACT = rq_get_var(gACT)
      end
  end
  
  # send the activation request to the gripper and
  # wait for its completion.
  def rq_activate_and_wait():
  	rq_activate()
  
  	while(not rq_is_gripper_activated()):
  		# wait for activation completed
  	end
  end
  def rq_act_and_wait():
    rq_activate_and_wait()
  end
  
  # interrupts the gripper motion.
  def rq_stop():
  	rq_set_var(rGTO,0)
  
      GTO = rq_get_var(gGTO)
      while (GTO != 0):
          GTO = rq_get_var(gGTO)
      end
  end
  
  # resets the activation and auto-release bits.
  def rq_reset():
  	rq_set_var(rATR,0)
  	rq_set_var(rACT,0)
  
      ACT = rq_get_var(gACT)
      while (ACT != 0):
          ACT = rq_get_var(gACT)
      end
  end
  
  # send the auto-release request and wait
  # for its completion
  def rq_auto_release_and_wait():
  	rq_set_var(rACT,1)
  	rq_set_var(rATR,1)
  
      ACT = rq_get_var(gACT)
      while (ACT != 1):
          ACT = rq_get_var(gACT)
      end
  
  	FLT = rq_get_var(gFLT)
  	while(FLT != 15):
  		FLT = rq_get_var(gFLT)
  	end
  end
  
  # set the force setpoint
  def rq_set_force(force):
  	rq_set_var(rFOR,force)
  end
  
  # set the speed setpoint
  def rq_set_speed(speed):
  	rq_set_var(rSPE,speed)
  end
  
  # send the open request to the gripper
  def rq_open():
  	rq_move(0)
  end
  
  # send the close request to the gripper
  def rq_close():
  	rq_move(255)
  end
  
  # send the open request to the gripper and wait
  # for its completion
  def rq_open_and_wait():
  	rq_move_and_wait(0)
  end
  def rq_open_wait():
  	rq_move_and_wait(0)
  end
  
  # send the close request to the gripper and wait
  # for its completion
  def rq_close_and_wait():
  	rq_move_and_wait(255)
  end
  def rq_close_wait():
  	rq_move_and_wait(255)
  end
  
  # send the move request to the position in argument
  def rq_move(pos):
  	rq_set_var(rGTO,0)
  
  	GTO = rq_get_var(gGTO)
  	while (GTO != 0):
  		GTO = rq_get_var(gGTO)
  	end
  
  	rq_set_var(rPOS,pos)
  
  	PRE = rq_get_var(gPRE)
  	while (PRE != pos):
  		PRE = rq_get_var(gPRE)
  	end
  
  	rq_set_var(rGTO,1)
  
  	while (GTO != 1):
  		GTO = rq_get_var(gGTO)
  	end
  
  end
  
  # send the move request to the position in argument
  # and wait for its completion
  def rq_move_and_wait(pos):
  	rq_move(pos)
  
  	while (not rq_is_motion_complete()):
  		# wait for motion completed
  		sleep(0.01)
  		sync()
  	end
  end
  def rq_move_wait(pos):
  	rq_move(pos)
  
  	while (not rq_is_motion_complete()):
  		# wait for motion completed
  		sleep(0.01)
  		sync()
  	end
  end
  
  # send the request to change mode in argument
  def rq_set_mode(value):
  	rq_set_var(rMOD, value)
  
      MOD = rq_get_var(gMOD)
      while (MOD != value):
          MOD = rq_get_var(gMOD)
      end
  end
  
  # send the request to change to the basic mode
  def rq_set_basic_mode():
  	rq_set_mode(0)
  end
  def rq_set_basic():
  	rq_set_mode(0)
  end
  
  # send the request to change to the pinch mode
  def rq_set_pinch_mode():
  	rq_set_mode(1)
  end
  def rq_set_pinch():
  	rq_set_mode(1)
  end
  
  # send the request to change to the wide mode
  def rq_set_wide_mode():
  	rq_set_mode(2)
  end
  def rq_set_wide():
  	rq_set_mode(2)
  end
  
  # send the request to change to the scissor mode
  def rq_set_scissor_mode():
  	rq_set_mode(3)
  end
  def rq_set_scissor():
  	rq_set_mode(3)
  end
  
  # returns True if the gripper has completed its motion
  # returns False otherwise
  def rq_is_motion_complete():
  	STA = rq_get_var(gSTA)
  
  	if (STA == 0):
  		return False
  	end
  
  	return True
  
  end
  
  # Returns True if the gripper is activated
  def rq_is_gripper_activated():
      IMC = rq_get_var(gIMC)
  
      if (IMC == 3):
          return True
      end
  
      return False
  end
  
  # returns True if an object has been detected
  def rq_is_object_detected():
  	STA = rq_get_var(gSTA)
  
  	if(STA == 1):
  		return True
  	elif(STA == 2):
  		return True
  	else:
  		return False
  	end
  end
  def rq_is_obj_detec():
  	STA = rq_get_var(gSTA)
  
  	if(STA == 1):
  		return True
  	elif(STA == 2):
  		return True
  	else:
  		return False
  	end
  end
  
  # prints in the log window the fault status
  def rq_print_fault_code():
  	fault_status = rq_get_var(gFLT)
  
  	if(fault_status == 0):
  		textmsg("Gripper Fault : ", "No Fault (0x00)")
  	elif (fault_status == 5):
  		textmsg("Gripper Fault : ", "Priority Fault: Action delayed, activation (reactivation) must be completed prior to renewed action (0x05)")
  	elif (fault_status == 6):
  		textmsg("Gripper Fault : ", "Priority Fault: Action delayed, mode change must be completed prior to continuing action (0x06)")
  	elif (fault_status == 7):
  		textmsg("Gripper Fault : ", "Priority Fault: The activation bit must be set prior to action (0x07)")
  	elif (fault_status == 9):
  		textmsg("Gripper Fault : ", "Minor Fault: The communication chip is not ready (may be booting) (0x09)")
  	elif (fault_status == 10):
  		textmsg("Gripper Fault : ", "Minor Fault: Changing mode fault, interference detected on Scissor (for less than 20 sec) (0x0A)")
  	elif (fault_status == 11):
  		textmsg("Gripper Fault : ", "Minor Fault: Automatic release in progress (0x0B)")
  	elif (fault_status == 13):
  		textmsg("Gripper Fault : ", "Major Fault: Activation fault, verify that no interference or other error occurred (0x0D)")
  	elif (fault_status == 14):
  		textmsg("Gripper Fault : ", "Major Fault: Changing mode fault, interference detected on Scissor (for more than 20 sec) (0x0E)")
  	elif (fault_status == 15):
  		textmsg("Gripper Fault : ", "Major Fault: Automatic release completed. Reset and activation is required (0x0F)")
  	else:
  		textmsg("Gripper Fault : ", "Unkwown Fault")
  	end
  end
  
  # sets the gripper inputs
  global current_force = 0
  global current_speed = 0
  def rq_set_var(name, value):
  
  	if (name == rACT):
          MOD = rq_get_var(gMOD)
          GTO = rq_get_var(gGTO)
          modbus_set_output_register("gripper_O0", 256 * (rACT * value + rMOD * MOD + rGTO * GTO), False)
  	elif (name == rMOD):
          ACT = rq_get_var(gACT)
          GTO = rq_get_var(gGTO)
          modbus_set_output_register("gripper_O0", 256 * (rACT * ACT + rMOD * value + rGTO * GTO), False)
  	elif (name == rGTO):
          ACT = rq_get_var(gACT)
          MOD = rq_get_var(gMOD)
         	modbus_set_output_register("gripper_O0", 256 * (rACT * ACT + rMOD * MOD + rGTO * value), False)
  	elif (name == rATR):
          ACT = rq_get_var(gACT)
          MOD = rq_get_var(gMOD)
          GTO = rq_get_var(gGTO)
         	modbus_set_output_register("gripper_O0", 256 * (rACT * ACT + rMOD * MOD + rGTO * GTO + rATR * value), False)
  	elif (name == rFOR):
          current_force = value
          modbus_set_output_register("gripper_O2", (256 * current_speed + value), False)
  	elif (name == rSPE):
          current_speed = value
         	modbus_set_output_register("gripper_O2", (256 * value + current_force), False)
  	elif (name == rPOS):
          modbus_set_output_register("gripper_O1", value, False)
      else:
      end
  
      sync()
  end
  
  # reads the gripper outputs
  def rq_get_var(name, nbr_bytes=0):
      if (name == gACT):
          reg = integer_to_binary_list(modbus_get_signal_status("gripper_I0", False))
          value = binary_list_to_integer([reg[gACT]])
      elif (name == gMOD):
          reg = integer_to_binary_list(modbus_get_signal_status("gripper_I0", False))
          value = binary_list_to_integer([reg[gMOD1], reg[gMOD2]])
      elif (name == gGTO):
          reg = integer_to_binary_list(modbus_get_signal_status("gripper_I0", False))
          value = binary_list_to_integer([reg[gGTO]])
      elif (name == gSTA):
          reg = integer_to_binary_list(modbus_get_signal_status("gripper_I0", False))
          value = binary_list_to_integer([reg[gSTA1], reg[gSTA2]])
      elif (name == gIMC):
          reg = integer_to_binary_list(modbus_get_signal_status("gripper_I0", False))
          value = binary_list_to_integer([reg[gIMC1], reg[gIMC2]])
      elif (name == gFLT):
          reg = integer_to_binary_list(modbus_get_signal_status("gripper_I1", False))
          value = binary_list_to_integer([reg[gFLT1], reg[gFLT2], reg[gFLT3], reg[gFLT4]])
      elif (name == gPRE):
          reg = modbus_get_signal_status("gripper_I1", False)
          value = reg % 256
      else:
     	    value = 0
      end
  
      sync()
  
      return value
  end
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Copilot, 1.28.1.22634, Robotiq Inc.
  #   Type: Copilot
  ###############################################################
  # Script file used to communicate with Robotiq's ft sensor
  # Version: 0.0.1
  ###############################################################

  node_rpc_server = rpc_factory("xmlrpc","http://127.0.0.1:4251/node")
  linalg = rpc_factory("xmlrpc","http://127.0.0.1:4251/linalg")
  storevar = rpc_factory("xmlrpc","http://127.0.0.1:4251/storevariable")
  kinematics_rpc_server = rpc_factory("xmlrpc","http://127.0.0.1:4251/")

  global Fx = 0.0
  global Fy = 0.0
  global Fz = 0.0
  global Mx = 0.0
  global My = 0.0
  global Mz = 0.0
  global T_base_sensor = p[0,0,0,0,0,0]
  global tcp_wrench = [0,0,0,0,0,0]
  global base_wrench = [0,0,0,0,0,0]
  global sensor_wrench = [0,0,0,0,0,0]
  global rq_depal_end_pose_offset = p[0,0,0,0,0,0]
  global rq_ft_sensor_connected = False

  rq_target_joint_positions = get_actual_joint_positions()
  rq_elapsed_time = 0
  rq_force_protect_urcap = 0.0
  rq_torque_protect_urcap = 0.0
  rq_collision_detection_enabled = False
  rq_collision_detection_active_time = 0.0
  rq_halt_on_collision_detection = True
  is_rq_prevent_steady_enabled = True
  rq_active_node = 0
  rq_node_executor_thread_running = False
  rq_lookahead_time = 0.05
  rq_continue_node_execution = True
  rq_controller_time_step = 0.008

  rq_linear_axis_move_abs_target_position = 0.0
  rq_linear_axis_move_abs_target_speed = 0.0
  rq_linear_axis_move_abs_target_acc = 0.0
  rq_linear_axis_move_abs_target_decel = 0.0
  rq_linear_axis_move_absolute_thread = 0
  rq_linear_axis_move_absolute_thread_running = False

  def pose_to_list(p):
    return [p[0], p[1], p[2], p[3], p[4], p[5]]
  end

  def list_to_pose(l):
    return p[l[0], l[1], l[2], l[3], l[4], l[5]]
  end

  def rq_init_path(pathId):
     initPathAnswer = node_rpc_server.initpath(pathId)
     verify_path_answer(initPathAnswer)
     return initPathAnswer[0]
  end

  def concat(str1, str2, str3):
    return str_cat(str1, str_cat(str2, str3))
  end
  def key_val(key, val):
    return concat(concat("`", key, "`"), ":", val)
  end

  thread rq_prevent_steady():
    local q_start = get_target_joint_positions()
    local q = q_start
    local p = 0

    while True:
      p = p + rq_controller_time_step*4*3.14159
      local offset = 0.000001*sin(p)
      q[5] = q_start[5] + offset
      servoj(q)
    end
  end

  def linear_axis_move_abs(target_position,
                           target_speed,
                           target_acceleration,
                           target_deceleration,
                           is_blocking,
                           prevent_steady = True):
    rq_linear_axis_move_abs_target_position = target_position
    rq_linear_axis_move_abs_target_speed = target_speed
    rq_linear_axis_move_abs_target_acc = target_acceleration
    rq_linear_axis_move_abs_target_decel = target_deceleration
    is_rq_prevent_steady_enabled = prevent_steady

    if( rq_linear_axis_move_absolute_thread_running ):
      kill rq_linear_axis_move_absolute_thread
    end
    rq_linear_axis_move_absolute_thread = run linear_axis_move_abs_thread()
    if(is_blocking):
      join rq_linear_axis_move_absolute_thread
    end
  end #linear_axis_move_abs

  thread linear_axis_move_abs_thread():

    if is_rq_prevent_steady_enabled:
      rq_prevent_steady_thread = run rq_prevent_steady()
    end

    rq_linear_axis_move_absolute_thread_running = True
    timeout_in_milliseconds = 500
    target_position_reached = False
    number_of_done_status_received_while_not_at_target = 0

    while( not target_position_reached ):
      move_absolute_response = node_rpc_server.linearaxismove(rq_linear_axis_move_abs_target_position,
                                                              rq_linear_axis_move_abs_target_speed,
                                                              rq_linear_axis_move_abs_target_acc,
                                                              rq_linear_axis_move_abs_target_decel,
                                                              timeout_in_milliseconds)

      if move_absolute_response == 0: # Done
        position_tolerance = 1e-3
        local position = node_rpc_server.linearaxisgetactualposition() # local because it is a variable under 15 chars that a user could have defined
        target_position_reached = ( norm( position - rq_linear_axis_move_abs_target_position ) < position_tolerance )
        if not target_position_reached:
          number_of_done_status_received_while_not_at_target = number_of_done_status_received_while_not_at_target + 1
          if ( number_of_done_status_received_while_not_at_target > 10 ): #When the move starts, it may take some time before the status changes from done to busy so we accept a certain number of done status without being at the target position
            textmsg("error: target position should be reached when move absolute status is Done")
          end
        end
      elif move_absolute_response == 1: # Normal (safeguard stopped, busy moving, or paused)
        # do nothing
      elif move_absolute_response == 2: # Error
        textmsg("Linear axis absolute move error")
        popup("Program paused because axis is not ready or the requested position is outside the allowed range.",
              title="Linear axis move error", warning=False, error=True, blocking=True)
        socket_send_line("pause", "RQDashboardClient") # If the axis is not ready, this allows the user to go fix it and then resume the program.
        sleep(1.0) # The socket_send_line command is non-blocking, so we need to wait for the progam to pause.
                   # Without the sleep, execution will continue and multiple popups and program pauses will be executed.
      end

      sleep(rq_controller_time_step)
    end #while
    rq_linear_axis_move_absolute_thread_running = False

    if is_rq_prevent_steady_enabled:
      kill rq_prevent_steady_thread
    end

  end # linear_axis_move_abs_thread

  def setup_force_node_on_server(generic_rq_insertion_force_node_id = 1,
                                 feature=1,
                                 targetforce = [0,0,0,0,0,0],
                                 force_control_enabled_axes = [False, False, False, False, False, False],
                                 max_negative_deviation_vector = [-0.1, -0.1, -0.1, -0.1, -0.1, -0.1],
                                 max_positive_deviation_vector = [0.1, 0.1, 0.1, 0.1, 0.1, 0.1],
                                 adaptiveStiffness = True):
    node_rpc_server.setforcecontrolfeature(generic_rq_insertion_force_node_id, feature)
    node_rpc_server.setforcecontroltargetforce(generic_rq_insertion_force_node_id, targetforce)
    node_rpc_server.setforcecontrolenabledaxes(generic_rq_insertion_force_node_id, force_control_enabled_axes)
    node_rpc_server.setforcecontrolmaximaldeviation(generic_rq_insertion_force_node_id, max_negative_deviation_vector, max_positive_deviation_vector)
    node_rpc_server.setforcecontroladaptivestiffnessenabledaxes(generic_rq_insertion_force_node_id, True)
  end

  def verify_path_answer(path_answer):
   initPathStatusCode = path_answer[1]
   handle_path_node_error_code(initPathStatusCode)
  end

  def handle_path_node_error_code(initPathStatusCode):
    if initPathStatusCode == -1:
      popup("Could not compute path with the selected options.", "Robotiq's FT Sensor", blocking=True, error=True)
    elif initPathStatusCode == 1:
      popup("Joint solution impossible. Change your starting position.", "Robotiq's FT Sensor", blocking=True, error=True)
    elif initPathStatusCode == 2:
      popup("Discontinuous path detected. Change your starting position.", "Robotiq's FT Sensor", blocking=True, error=True)
    elif initPathStatusCode == 3:
      popup("Path time limit has been reached. Increase the speed of your path or break it down in multiple shorter paths.", "Robotiq's FT Sensor", blocking=True, error=True)
    elif initPathStatusCode == 4:
      popup("Could not compute path with the selected options. Computing path timeout.", "Robotiq's FT Sensor", blocking=True, error=True)
    elif initPathStatusCode == 5:
      popup("Path computation was aborted.", "Robotiq's FT Sensor", blocking=True, error=True)
    elif initPathStatusCode == 6:
      popup("A previous path computation is still in progress. Please try again in a few seconds.", "Robotiq's FT Sensor", blocking=True, error=True)
    elif initPathStatusCode == 7:
      textmsg("Path initialization error: Invalid path id.") # No popup needed in this case.
    elif initPathStatusCode == 8:
      popup("Palletizer error: box number out of range.", blocking=True, error=True)
    elif initPathStatusCode == 9:
      popup("Palletizer error: collision detected.", blocking=True, error=True)
    elif initPathStatusCode == 10:
      popup("Palletizer error: boxes overlap in layer.", blocking=True, error=True)
    elif initPathStatusCode == 11:
      popup("Palletizer error: empty layer.", blocking=True, error=True)
    elif initPathStatusCode == 12:
      popup("Palletizer error: The PLC was not connected during node creation.", blocking=True, error=True)
    elif initPathStatusCode != 0:
      textmsg("Unexpected initPathStatusCode value : ", initPathStatusCode)
    end

    if initPathStatusCode != 0:
      halt
    end
  end

  def rq_zero_sensor():
    if (socket_open("127.0.0.1", 63350, "rq_ft_sensor_acc")):
        socket_send_string("SET ZRO", "rq_ft_sensor_acc")
        sleep(0.1)
        socket_close("rq_ft_sensor_acc")
    end
  end

  def rq_wait_ft_sensor_steady(timeout = 2000):

    max_mean_squared_error = [0.1, 0.1, 0.1, 0.0001, 0.0001, 0.0001]
    local mean = sensor_wrench

    mean_squared_error = sensor_wrench
    local i = 0
    while i<6:
      mean_squared_error[i] = mean_squared_error[i] * mean_squared_error[i]
      i=i+1
    end

    is_sensor_steady = False
    local alpha = 0.9
    local timer = 0

    while (not is_sensor_steady) and (timer < timeout):
      sleep(rq_controller_time_step)
      timer = timer + 8

      i = 0
      while i < 6:
        mean[i] = alpha * mean[i] + (1.0 - alpha) * sensor_wrench[i]
        error = sensor_wrench[i] - mean[i]
        mean_squared_error[i] = alpha * mean_squared_error[i] + ((1.0 - alpha) * error * error)
        i = i+1
      end

      is_sensor_steady = True
      i = 0
      while (i < 6) and is_sensor_steady:
        is_sensor_steady = mean_squared_error[i] < max_mean_squared_error[i]
        i = i+1
      end
    end

    return is_sensor_steady
  end

  thread rq_elapsed_timer_ms():
    rq_elapsed_time = 0
  dt = 1000/125
    while True:
      rq_elapsed_time =  rq_elapsed_time + dt
      sync()
    end
  end

  def get_sensor_fx():
    return Fx
  end

  def get_sensor_fy():
    return Fy
  end

  def get_sensor_fz():
    return Fz
  end

  def get_sensor_mx():
    return Mx
  end

  def get_sensor_my():
    return My
  end

  def get_sensor_mz():
    return Mz
  end

  def get_applied_tcp_force(index):
    return -1.0 * tcp_wrench[index]
  end

  def get_applied_base_force(index):
    return -1.0 * base_wrench[index]
  end

  def express_vector_in_new_frame(T_from_to, V_from):
    Q_from_to = p[0, 0, 0, T_from_to[3], T_from_to[4], T_from_to[5]]
    V_to = pose_trans(pose_inv(Q_from_to), p[V_from[0], V_from[1], V_from[2], 0, 0, 0])
    return [V_to[0], V_to[1], V_to[2]]
  end

  def express_force_in_frame(T_from_to, wrench_from):
    F = express_vector_in_new_frame(T_from_to, [wrench_from[0], wrench_from[1], wrench_from[2]])
    T = express_vector_in_new_frame(T_from_to, [wrench_from[3], wrench_from[4], wrench_from[5]])
    return [F[0], F[1], F[2], T[0], T[1], T[2]]
  end

  def express_pose_A_relative_to_pose_B(pose_A, pose_B):
    return pose_trans(pose_inv(pose_B), pose_A)
  end

  thread read_force():


  if (not socket_open("127.0.0.1", 63351, "rq_ft_sensor_stream")):
    popup("Can't connect to the FT Sensor driver", "Robotiq's FT Sensor", error=True)
    halt
  end

  socket_close("rq_ft_sensor_stream")
  if (not socket_open("127.0.0.1", 63350, "rq_ft_sensor_stream")):
    popup("Can't connect to the FT Sensor driver", "Robotiq's FT Sensor", error=True)
    halt
  end

    if (not socket_open("127.0.0.1", 29999, "RQDashboardClient")):
      popup("Can't connect to the Dashboard server", "Robotiq's FT Sensor", error=True)
      halt
    end

    rq_collision_detection_active_count = 0
    rq_collision_detection_active = False

    while True:
        socket_send_string("READ DATA", "rq_ft_sensor_stream")
        rq_sensor_data = socket_read_ascii_float(6, "rq_ft_sensor_stream")

        if (rq_sensor_data[0] >= 6):
            Fx = rq_sensor_data[1]
            Fy = rq_sensor_data[2]
            Fz = rq_sensor_data[3]
            Mx = rq_sensor_data[4]
            My = rq_sensor_data[5]
            Mz = rq_sensor_data[6]
        else:
            Fx = 0.0
            Fy = 0.0
            Fz = 0.0
            Mx = 0.0
            My = 0.0
            Mz = 0.0
        end

        T_base_tcp = get_actual_tcp_pose()
        T_base_flange = get_actual_tool_flange_pose()
        T_flange_sensor = p[0, 0, 0.0375, 0, 0, 0]
        T_base_sensor = pose_trans(T_base_flange, T_flange_sensor)

        T_flange_tcp = pose_trans( pose_inv(T_base_flange), T_base_tcp)
        T_sensor_tcp = pose_trans( pose_inv(T_flange_sensor), T_flange_tcp)

        sensor_wrench = [Fx, Fy, Fz, Mx, My, Mz]
        tcp_wrench = wrench_trans(pose_inv(T_sensor_tcp), sensor_wrench)
        base_wrench = express_force_in_frame(pose_inv(T_base_tcp), tcp_wrench)


        write_output_float_register(TCP_FX_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[0])
        write_output_float_register(TCP_FY_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[1])
        write_output_float_register(TCP_FZ_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[2])
        write_output_float_register(TCP_MX_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[3])
        write_output_float_register(TCP_MY_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[4])
        write_output_float_register(TCP_MZ_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[5])

        if rq_collision_detection_enabled:
            if rq_collision_detection_active_time < (0.5*rq_controller_time_step):
                if norm([Fx, Fy, Fz]) > rq_force_protect_urcap:
                    rq_on_collision_detection("Force limit value exceeded.")
                elif norm([Mx, My, Mz]) > rq_torque_protect_urcap:
                    rq_on_collision_detection("Torque limit value exceeded.")
                end
            else:
                rq_collision_detection_active_time = rq_collision_detection_active_time + rq_controller_time_step
                if rq_collision_detection_active_time >= 1.0:
                    rq_collision_detection_active_time = 0.0
                end
            end
        end


    end
  end

  def rq_get_ft_sensor_state():
    socket_open("127.0.0.1",63350,"rq_ft_sensor_state")
    socket_send_string("CURRENT STATE", "rq_ft_sensor_state")
    rq_sensor_state = socket_read_string("rq_ft_sensor_state")
    socket_close("rq_ft_sensor_state")

    if rq_sensor_state == "":
      rq_sensor_state = "RQ_STATE_INIT"
    end

    return rq_sensor_state
  end

  def rq_ft_sensor_disconnected_warn_user():
    socket_open("127.0.0.1",29999,"SensorWarning")
    socket_send_string("popup FT Sensor must be connected to run this program.","SensorWarning")
    socket_send_byte(10,"SensorWarning")
    socket_close("SensorWarning")
  end

  def rq_ft_sensor_disconnected_stop_program():
    socket_open("127.0.0.1", 30002, "rq_ft_sensor_stop_socket")

    socket_send_string("def rq_ft_sensor_stop_program():", "rq_ft_sensor_stop_socket")
    socket_send_byte(10, "rq_ft_sensor_stop_socket")
    socket_send_string("  stopj(5.0)", "rq_ft_sensor_stop_socket")
    socket_send_byte(10, "rq_ft_sensor_stop_socket")
    socket_send_string("end", "rq_ft_sensor_stop_socket")
    socket_send_byte(10, "rq_ft_sensor_stop_socket")

    socket_close("rq_ft_sensor_stop_socket")
  end

  def rq_ft_sensor_disconnected_check():
    if rq_get_ft_sensor_state() == "RQ_STATE_INIT":
      rq_ft_sensor_disconnected_stop_program()
      rq_ft_sensor_disconnected_warn_user()

      return True
    else:
      return False
    end
  end

  #RTDE input registers
  TARGET_JOINT_0_INPUT_REGISTER_DOUBLE = 40
  TARGET_JOINT_1_INPUT_REGISTER_DOUBLE = 41
  TARGET_JOINT_2_INPUT_REGISTER_DOUBLE = 42
  TARGET_JOINT_3_INPUT_REGISTER_DOUBLE = 43
  TARGET_JOINT_4_INPUT_REGISTER_DOUBLE = 44
  TARGET_JOINT_5_INPUT_REGISTER_DOUBLE = 45
  FINISH_NODE_INPUT_REGISTER_INT32 = 40
  RUNTIME_ERROR_INPUT_REGISTER_INT32 = 41
  ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32 = 42

  #RTDE output registers
  ACTIVE_NODE_OUTPUT_REGISTER_INT32 = 40
  NODE_EXECUTION_OUTPUT_COUNT_INT32 = 41
  ACTIVATION_NODE_COUNT_OUTPUT_REGISTER_INT32 = 42
  TCP_FX_ACTUAL_OUTPUT_DOUBLE = 34
  TCP_FY_ACTUAL_OUTPUT_DOUBLE = 35
  TCP_FZ_ACTUAL_OUTPUT_DOUBLE = 36
  TCP_MX_ACTUAL_OUTPUT_DOUBLE = 37
  TCP_MY_ACTUAL_OUTPUT_DOUBLE = 38
  TCP_MZ_ACTUAL_OUTPUT_DOUBLE = 39
  GENERAL_OUTPUT_DOUBLE_40 = 40
  GENERAL_OUTPUT_DOUBLE_41 = 41
  GENERAL_OUTPUT_DOUBLE_42 = 42
  GENERAL_OUTPUT_DOUBLE_43 = 43
  GENERAL_OUTPUT_DOUBLE_44 = 44
  GENERAL_OUTPUT_DOUBLE_45 = 45

  write_output_integer_register(ACTIVE_NODE_OUTPUT_REGISTER_INT32, 0)
  write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, 0)
  write_output_integer_register(ACTIVATION_NODE_COUNT_OUTPUT_REGISTER_INT32, 0)
  write_output_float_register(TCP_FX_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_FY_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_FZ_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_MX_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_MY_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_MZ_ACTUAL_OUTPUT_DOUBLE, 0)

  global activation_node_count = 0
  global node_execution_count = 0

  def element_wise_subtract(l1, l2):
    local r = l1
    local i = 0
    while i<length(r):
      r[i]=l1[i]-l2[i]
      i=i+1
    end
    return r
  end

  def element_wise_add(l1, l2):
    local result = l1
    local i = 0
    while i < length(result):
      result[i] = l1[i] + l2[i]
      i = i + 1
    end
    return result
  end

  def list_by_scalar_multiply(l1, scalar):
      local r = l1
      local i = 0
      while i<length(r):
        r[i]=l1[i]*scalar
        i=i+1
      end
      return r
   end

  def norm_inf(v):
    local norm = 0
    local i = 0
    while i<length(v):
        n = norm(v[i])
        if(n > norm):
          norm = n
        end
      i=i+1
    end
    return norm
  end

  def active_and_reset_node(nodeId):
    server_activation_node_count = read_input_integer_register(ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32)

    activation_node_count = activation_node_count + 1
    node_execution_count = 0
    write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, node_execution_count)
    rq_active_node = nodeId
    write_output_integer_register(ACTIVE_NODE_OUTPUT_REGISTER_INT32, nodeId)
    write_output_integer_register(ACTIVATION_NODE_COUNT_OUTPUT_REGISTER_INT32, activation_node_count)

    while server_activation_node_count == read_input_integer_register(ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32):
      sleep(rq_controller_time_step)
    end
  end

  def execute_node(nodeId, startThread = False):
    node_execution_thread = 0
    active_and_reset_node(nodeId)
    if startThread:
      rq_target_joint_positions = get_actual_joint_positions()
      movej(rq_target_joint_positions) # This movej is used to prevent the "another thread is already controlling the robot" error.
      rq_continue_node_execution = True
      node_execution_thread = run execute_node_thread()
    end
    while not active_node_completed():
      sync()
    end
    return node_execution_thread
  end

  def setup_node_execution_related_variables():
    activation_node_count = 0
    node_execution_count = 0
    write_output_integer_register(ACTIVE_NODE_OUTPUT_REGISTER_INT32, 0)
    write_output_integer_register(ACTIVATION_NODE_COUNT_OUTPUT_REGISTER_INT32, activation_node_count)
    write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, node_execution_count)
    sleep(rq_controller_time_step)
  end

  def start_node_executor():
    setup_node_execution_related_variables()

    succeeded = node_rpc_server.startnodeexecutor()
    if not succeeded:
      node_rpc_server.stopnodeexecutor()
      sleep(0.5) # Needed for URControl to free the input registers.
      succeeded = node_rpc_server.startnodeexecutor()
      if not succeeded:
        popup("RTDE interface cannot initialize. Make sure that Ethernet/IP adapter and Profinet are disabled, and that no other URCaps use the RTDE interface.", "Robotiq Copilot", error=True)
        halt
      end
    end

    hand_shake_xmlrpcserver()
  end

  def reset_node_executor():
    setup_node_execution_related_variables()

    succeeded = node_rpc_server.resetnodeexecutor()
    if not succeeded:
      popup("RTDE interface cannot initialize. Make sure that Ethernet/IP adapter and Profinet are disabled, and that no other URCaps use the RTDE interface.", "Robotiq Copilot", error=True)
      halt
    end

    hand_shake_xmlrpcserver()
  end

  def hand_shake_xmlrpcserver():
    timer_thread = run rq_elapsed_timer_ms()
    sleep(rq_controller_time_step)
    node_execution_initialized = False
    while (not node_execution_initialized) and (rq_elapsed_time < 100):
      node_execution_initialized = (read_input_integer_register(FINISH_NODE_INPUT_REGISTER_INT32) == -1)
      sleep(rq_controller_time_step)
    end
    kill timer_thread

    if (not node_execution_initialized):
      popup("Node Execution initialization failed.", "Robotiq Copilot", error=True)
      halt
    end
  end

  thread execute_node_thread():
    rq_target_joint_positions = get_actual_joint_positions()
    servoj(rq_target_joint_positions)
    while rq_continue_node_execution:
      new_rq_target_joint_positions = update_target_position()
      joint_target_distances = element_wise_subtract(new_rq_target_joint_positions, rq_target_joint_positions)
      max_joint_target_displacement = norm_inf(joint_target_distances)
      if max_joint_target_displacement > 0.2:
          textmsg("previous target position: ", rq_target_joint_positions)
          textmsg("next target position: ", new_rq_target_joint_positions)
          textmsg("max joint target displacement: ", max_joint_target_displacement)
          popup("Node executor error: see Log tab for details", "Robotiq Copilot", False, True, True)
          halt
      end


      servoj(new_rq_target_joint_positions, t=rq_controller_time_step, lookahead_time=rq_lookahead_time, gain=500)
      rq_target_joint_positions = new_rq_target_joint_positions
    end
    stopj(5)
  end

  # The thread below is used to prevent "another thread is already controlling the robot error".
  # In some occasions, even a sleep(0.05) will not work so this is necessary (until fixed by UR).
  # The thread is immediately killed to avoid unnecessary motion for the case of a parent node
  # that modifies the servoj target joint positions.
  def kill_thread( thread_id ):
    kill thread_id
    run_movej_thread = run movej_thread()
    sleep(rq_controller_time_step)
    kill run_movej_thread
  end

  thread movej_thread():
    movej(rq_target_joint_positions)
  end

  def active_node_completed():
    return (read_input_integer_register(ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32) == activation_node_count) and
           (read_input_integer_register(FINISH_NODE_INPUT_REGISTER_INT32) == rq_active_node)
  end

  def rq_handle_error_code(code):
    message = "Runtime error!"

    if code == 1:
      message = "Robotiq license error!"
    elif code == 2:
      message = "Program stopped due to runtime error. Please restart the program."
    end

    popup(message, "Robotiq Copilot", error=True)
    halt
  end

  def update_target_position():

    error_code = read_input_integer_register(RUNTIME_ERROR_INPUT_REGISTER_INT32)

    if error_code != 0:
      rq_handle_error_code(error_code)
    end

    new_rq_target_joint_positions = [0,0,0,0,0,0]
    new_rq_target_joint_positions[0] = read_input_float_register(TARGET_JOINT_0_INPUT_REGISTER_DOUBLE)
    new_rq_target_joint_positions[1] = read_input_float_register(TARGET_JOINT_1_INPUT_REGISTER_DOUBLE)
    new_rq_target_joint_positions[2] = read_input_float_register(TARGET_JOINT_2_INPUT_REGISTER_DOUBLE)
    new_rq_target_joint_positions[3] = read_input_float_register(TARGET_JOINT_3_INPUT_REGISTER_DOUBLE)
    new_rq_target_joint_positions[4] = read_input_float_register(TARGET_JOINT_4_INPUT_REGISTER_DOUBLE)
    new_rq_target_joint_positions[5] = read_input_float_register(TARGET_JOINT_5_INPUT_REGISTER_DOUBLE)

    node_execution_count = node_execution_count + 1
    write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, node_execution_count)
    return new_rq_target_joint_positions
  end

  def set_servoj_node_cmd(q):
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_40, q[0])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_41, q[1])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_42, q[2])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_43, q[3])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_44, q[4])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_45, q[5])
  end

  def rq_collision_detection_start(force_limit = 140, torque_limit = 14, halt_on_collision = True):
    rq_force_protect_urcap = force_limit
    rq_torque_protect_urcap = torque_limit
    rq_collision_detection_active_time = 0.0
    rq_collision_detection_enabled = True
    rq_halt_on_collision_detection = halt_on_collision
  end

  def rq_collision_detection_stop():
    rq_collision_detection_enabled = False
  end

  def rq_on_collision_detection(message):
    textmsg("Collision Detection. " + message)
    popupTitle = "Collision Detection"
    if rq_halt_on_collision_detection:
      popup(message + " Program halt.", popupTitle, False, True, False)
      halt
    else:
      popup(message + " Program suspend.", popupTitle, True, False, False)
      socket_send_line("pause", "RQDashboardClient")
      rq_collision_detection_active_time = rq_controller_time_step
    end
  end

  def round(number_to_round):
    if number_to_round - floor(number_to_round) < 0.5:
      return floor(number_to_round)
    else:
      return ceil(number_to_round)
    end
  end

  def rq_execute_box_trajectory(nodeId, current_box_count, has_box_payload, end_pose_offset = p[0,0,0,0,0,0]):
    local payload_mass = get_target_payload()
    local payload_cog  = get_target_payload_cog()
    local flange_payload = [payload_mass, payload_cog[0], payload_cog[1], payload_cog[2]]

    path_answer = node_rpc_server.initboxtrajectory(nodeId, current_box_count, has_box_payload, flange_payload, end_pose_offset)

    verify_path_answer(path_answer)
    reset_node_executor()
    node_execution_thread = execute_node(nodeId, True)
    rq_continue_node_execution = False
    join node_execution_thread
  end

  ################################
  # MAIN
  ################################

  run read_force()
  start_node_executor()
rtde_set_watchdog("external_force_torque", 5, "ignore")
ft_rtde_input_enable(False)
textmsg("disable external sensor")  
  preparationErrorXmlRpcClient = rpc_factory("xmlrpc","http://localhost:42267")
  contactOffsetXmlRpcClient = rpc_factory("xmlrpc","http://localhost:42327")
  palletizerXmlRpcClient = rpc_factory("xmlrpc","http://localhost:55827")
  machineTendingXmlRpcClient = rpc_factory("xmlrpc","http://localhost:56195")
    ###############################################################
    # Halt if a script preparation error occurred
    ###############################################################
    def checkForScriptPreparationException():
      if(preparationErrorXmlRpcClient.hasErrorOccurred()):
        popup(preparationErrorXmlRpcClient.getErrorMessage(), title=preparationErrorXmlRpcClient.getNodeInErrorTitle(), error=True, blocking=True)
        halt
      end
    end
  
    checkForScriptPreparationException()
  #***********************************************************************************************
  # verify tap detection
  #***********************************************************************************************
  
  def rq_tap_count(forces, high_threshold):
  
    low_threshold = 2
    tapCount = 0
    lookingForPeak = True
    indexDown = 0
  
    i = 1
    lastIndex = length(forces) - 1
    while i <= lastIndex:
  
      deltaForce = forces[i] - forces[0]
  
     if lookingForPeak:
        if deltaForce >  high_threshold:
          lookingForPeak = False
        end
      else:
        if deltaForce < low_threshold:
          tapCount = tapCount + 1
          lookingForPeak = True
          indexDown = i
        end
      end
      i = i + 1
  
    end
  
    if indexDown != lastIndex:
      tapCount = 0
    end
  
    return tapCount
  
  end
  def shift_right(list, default_value = 0):
  
     i = length(list)-1
     while (i > 0):
        list[i]=list[i-1]
        i=i-1
     end
     list[0] = default_value
  
     return list
  end
  
  #***********************************************************************************************
  # Wait for force reached
  #***********************************************************************************************
  # desired_wrench : desired wrench
  # is_active      : list of 0 and 1, 1 : axis is controlled
  # feature        : 0:base, 1:tcp
  # timeout        : timeout in miliseconds
  #***********************************************************************************************
  def rq_wait_for_force_reached(desired_wrench, is_active, feature, timeout):
  
    feature_base = 0
    feature_tool = 1
    time_constant = 0.025
    alpha = 1 - pow(2.718, -1.0 * rq_controller_time_step / time_constant)
  
    thresholds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    minimal_thresholds = [1.0, 1.0, 1.0, 0.1, 0.1, 0.1]
  
    applied_wrench = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    filtered_wrench = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  
    if (feature == feature_base):
      applied_wrench = list_by_scalar_multiply(base_wrench, -1.0)
    else:
      applied_wrench = list_by_scalar_multiply(tcp_wrench, -1.0)
    end
    filtered_wrench = applied_wrench
  
    i = 0
    while (i < 6):
      if (is_active[i]):
        thresholds[i] = 0.05 * norm(desired_wrench[i])
        if thresholds[i] < minimal_thresholds[i]:
          thresholds[i] = minimal_thresholds[i]
        end
      else:
        thresholds[i] = 10000
      end
      i = i+1
    end
  
   force_reached = False
  
   timer = 0
  
   while ((not force_reached) and (timer < timeout)):
  
      if (feature == feature_base):
         applied_wrench = list_by_scalar_multiply(base_wrench, -1.0)
      else:
         applied_wrench = list_by_scalar_multiply(tcp_wrench, -1.0)
      end
  
      i = 0
      while (i < 6):
        filtered_wrench[i] = (alpha * applied_wrench[i]) + ((1.0 - alpha) * filtered_wrench[i])
        i = i+1
      end
  
      force_reached = True
  
      i = 0
      while ((i < 6) and force_reached):
        error = norm(desired_wrench[i] - filtered_wrench[i])
        if (error > thresholds[i]):
          force_reached = False
        end
        i = i + 1
      end
  
      timer = timer + rq_controller_time_step
  
      sleep(rq_controller_time_step)
  
    end
  
    return force_reached
  end
  #***********************************************************************************************
  # verify click detection
  #***********************************************************************************************
  click_detection_children_ended = False
  
  def rq_click_detection(force_drop_threshold = 10, torque_drop_threshold = 1, force_radio_button_selected = True):
  
    current_norm = 0
    drop_threshold = 0
    norms = [0.0, 0.0, 0.0, 0.0, 0.0]
    click_detected = False
    wrench_indices = [0,0,0]
  
    if(force_radio_button_selected):
      drop_threshold = force_drop_threshold
      wrench_indices = [0,1,2]
    else:
      drop_threshold =torque_drop_threshold
      wrench_indices = [3,4,5]
    end
  
    while ((not click_detection_children_ended) and (not click_detected)):
  
      current_norm = norm([sensor_wrench[wrench_indices[0]], sensor_wrench[wrench_indices[1]], sensor_wrench[wrench_indices[2]]])
  
      norms[4] = norms[3]
      norms[3] = norms[2]
      norms[2] = norms[1]
      norms[1] = norms[0]
      norms[0] = current_norm
  
      avg_norm = (norms[2] + norms[3] + norms[4]) / 3.0
  
      #Check if clicking is detected with force
      norm_drop = avg_norm - current_norm
      if(norm_drop > drop_threshold):
        textmsg("Click detected")
        click_detected=True
      else:
        sleep(rq_controller_time_step)
      end
    end
  
    return click_detected
  end
  ###############################################################
  # Script file used to define Robotiq functions for the Insertion node
  # Version: 0.0.2
  ###############################################################
  
  rq_ins_offset = p[0, 0, 0, 0, 0, 0]
  rq_ins_start_pose = p[0, 0, 0, 0, 0, 0]
  rq_actual_to_destination = p[0, 0, 0, 0, 0, 0]
  rq_ins_destination =p[0, 0, 0, 0, 0, 0]
  rq_ins_speed_setting = 0
  rq_rotation_not_completed = False
  rq_find_bottom_not_completed = False
  rq_spiral_not_completed = False
  
  def ins_actual_force_urcap(direction="X+"):
    axis = str_at(direction, 0)
    if (axis == "x") or (axis == "X"):
      return norm(get_applied_tcp_force(0))
    elif (axis == "y") or (axis == "Y"):
      return norm(get_applied_tcp_force(1))
    elif (axis == "z") or (axis == "Z"):
      return norm(get_applied_tcp_force(2))
    else:
      textmsg("ins_actual_force_urcap, invalid direction ", direction)
    end
  end
  
  def ins_actual_torque_urcap(direction = "Z+"):
    if (direction == "X+") or (direction == "X-") or (direction == "X"):
      return get_applied_tcp_force(3)
    elif (direction == "Y+") or (direction == "Y-") or (direction == "Y"):
      return get_applied_tcp_force(4)
    else:
      return get_applied_tcp_force(5)
    end
  
  end
  
  def square(a):
    return a*a
  end
  
  def update_servoj_node_target(target_joint_pos):
    set_servoj_node_cmd(target_joint_pos)
    sleep(rq_controller_time_step)
  end
  
  def create_all_insertion_nodes():
    global rq_insertion_force_node_id = node_rpc_server.createnewforcenode()
    global rq_insertion_movej_node_id = node_rpc_server.createnewmovejnode()
    global rq_insertion_servoj_node_id = node_rpc_server.createnewservojnode()
    node_rpc_server.setparentid(rq_insertion_movej_node_id, rq_insertion_force_node_id)
    node_rpc_server.setparentid(rq_insertion_servoj_node_id, rq_insertion_force_node_id)
  end
  
  def get_offset_projected_in_spiral_plane(direction, current_pose, pose_ref):
    axis = str_at(direction, 0)
    axis_index = 0
    if axis == "X":
      axis_index = 0
    elif axis == "Y":
      axis_index = 1
    elif axis == "Z":
      axis_index = 2
    else:
      textmsg("get_offset_projected_in_spiral_plane, invalid direction ", direction)
    end
  
    pose_offset = pose_trans( pose_inv(pose_ref), current_pose ) # current_pose and pose_ref should have the same orientations.
                                                                 # pose_offset is returned expressed in pose_ref frame
  
    pose_offset[axis_index] = 0 # valeur en direction mise a zero
    pose_offset[3] = 0 # valeur en Rx mise a zero
    pose_offset[4] = 0 # valeur en Ry mise a zero
    pose_offset[5] = 0 # valeur en Rz mise a zero
  
    return pose_offset
  end
  
  def update_spiral_offset(direction, spiral_initial_pose, spiral_initial_pose_offset, spiral_initial_pose_offset_name):
    pos_diff_tcp = get_offset_projected_in_spiral_plane(direction, get_actual_tcp_pose(), spiral_initial_pose)
    spiral_initial_pose_offset = interpolate_pose(spiral_initial_pose_offset, pos_diff_tcp, 0.35)
    storevar.setvariablepose(spiral_initial_pose_offset_name, spiral_initial_pose_offset)
  end
  
  def determine_max_spiral_radius_from_actual_position(direction, spiral_initial_pose, max_radius):
      dist_to_initial_pose = norm( get_offset_projected_in_spiral_plane(direction, get_actual_tcp_pose(), spiral_initial_pose))
      if (max_radius > dist_to_initial_pose):
        new_max_radius = max_radius - dist_to_initial_pose
      else:
        new_max_radius = 0
      end
  
      return new_max_radius
  end
  
  def insertion_compliant_move_urcap(axis = "Z",
                                     direction_sign = 1,
                                     compliant_insert_force_threshold = 20,
                                     speed = 0.04,
                                     feature = 1,
                                     max_position_deviation = 0.1):
    feature_base = 0
    feature_tool = 1
  
    if axis == "X":
      axis_index = 0
    elif axis == "Y":
      axis_index = 1
    elif axis == "Z":
      axis_index = 2
    else:
      textmsg("insertion_compliant_move_urcap, invalid direction ", axis)
    end
  
    current_pose = get_actual_tcp_pose()
    insertion_offset = p[0,0,0,0,0,0]
    rq_actual_to_destination = pose_trans(pose_inv(current_pose), rq_ins_destination)
    insertion_offset[axis_index] = rq_actual_to_destination[axis_index]
    insertion_pose = pose_trans(current_pose, insertion_offset)
    distance = point_dist(current_pose, insertion_pose)
    number_of_steps = floor( distance / (speed * rq_controller_time_step) ) + 1
    alpha_step  = 1.0 / number_of_steps
  
    # initialize forcenode
    node_execution_thread = initialise_force_node(position_controlled_direction = axis_index,
                                                  feature = feature_tool,
                                                  max_position_deviation = max_position_deviation)
  
    alpha = 0.0
    surface_found = False
    while (alpha <= 1.0) and (not surface_found):
      alpha = alpha + alpha_step
      interpolated_pose = interpolate_pose(current_pose, insertion_pose, alpha)
      q0 = get_inverse_kin(interpolated_pose) # define waypoint target
      update_servoj_node_target(q0)
      force = 0
      if feature == feature_base:
        force = get_applied_base_force(axis_index)
      elif feature == feature_tool:
        force = get_applied_tcp_force(axis_index)
      end
      if (direction_sign * force) >= compliant_insert_force_threshold:
        surface_found = True
      end
    end
  
    final_pos_reached = (alpha >= 1)
  
    kill_thread( node_execution_thread )
  
    return final_pos_reached
  end # insertion_compliant_move_urcap
  
  def insert_spiral_find_hole(axis = "Z", direction_sign = 1,
                              stop_force_threshold = 3,
                              max_radius = 0.005,
                              radius_incr_per_turn = 0.0003,
                              peck_mode = False,
                              tangential_speed = 0.005):
  
    if (stop_force_threshold < 0) or (stop_force_threshold > 40):
      popup("stop_force_threshold parameter in Newton must be between 0 and 40 Newtons","ERROR rq_insert_spiral_urcap")
      halt
    end
    if (max_radius < 0) or (max_radius > 0.05):
      popup("max_radius parameter must be between 0 mm and 50 mm","ERROR rq_insert_spiral_urcap")
      halt
    end
    if (radius_incr_per_turn < 0.00001) or (radius_incr_per_turn > 0.005):
      popup("radius_incr_per_turn parameter in mm must be between 0.01 mm and 5 mm","ERROR rq_insert_spiral_urcap")
      halt
    end
  
    rq_spiral_not_completed = False
  
    ins_x = 0
    ins_y = 0
    ins_z = 0
    ins_pose = p[0, 0, 0, 0, 0, 0]
    ins_current_pos = p[0, 0, 0, 0, 0, 0]
    ins_actual_angle = 0
    ins_search_result = False
    ins_radius_offset = 0
    ins_PI = 3.14159
    radius_inc_per_rad = radius_incr_per_turn / (2*ins_PI)
    ins_actual_radius = 0.0001  #Start radius
    ins_desired_arc_length = tangential_speed * rq_controller_time_step
  
    sleep(rq_controller_time_step)
    #Find the bore of the part
    ins_current_pos = get_actual_tcp_pose()
    sleep(rq_controller_time_step)
  
    # if axis == "Z"
    search_axis = 2
    other_axis_A = 0
    other_axis_B = 1
    if (axis == "X"):
      search_axis = 0
      other_axis_A = 1
      other_axis_B = 2
    elif (axis == "Y"):
      search_axis = 1
      other_axis_A = 2
      other_axis_B = 0
    end
  
    #********************************************************************************************************************
    #Spiral Search using any Axis
    #********************************************************************************************************************
    while ((ins_actual_radius <= max_radius) and (ins_actual_force_urcap(axis) >= stop_force_threshold)):
      if peck_mode:
        #Fragile mode, the robot rises between each new point
        #Retreat from position
        ins_pose[search_axis] = -0.002 * direction_sign
        next_tcp_pose = pose_trans(ins_current_pos,ins_pose)
        movej(next_tcp_pose)
        sleep(0.1)
        #Rotate
        ins_desired_arc_length = 0.0005
        delta_angle = ins_desired_arc_length / ins_actual_radius #small angle approximation
        ins_actual_angle = ins_actual_angle + delta_angle
  
        ins_pose[other_axis_A] = cos( ins_actual_angle ) * ins_actual_radius
        ins_pose[other_axis_B] = sin( ins_actual_angle ) * ins_actual_radius
  
        ins_actual_radius = ins_actual_angle * radius_inc_per_rad + ins_radius_offset
        next_tcp_pose = pose_trans(ins_current_pos, ins_pose)
        movej(next_tcp_pose)
        sleep(0.1)
        #Re-establish contact with the part
        ins_pose[search_axis] = 0.0005 * direction_sign
        next_tcp_pose = pose_trans(ins_current_pos, ins_pose)
        movel(next_tcp_pose, a=0.6, v=rq_ins_speed_setting)
        sleep(0.2)
      else:
        #standard mode: the Spiral_Search function will maintain contact between both mating parts at all times
        ins_pose[other_axis_A] = cos( ins_actual_angle ) * ins_actual_radius
        ins_pose[other_axis_B] = sin( ins_actual_angle ) * ins_actual_radius
  
        delta_angle = ins_desired_arc_length / ins_actual_radius
        ins_actual_angle = ins_actual_angle + delta_angle
        ins_actual_radius = ins_actual_angle * radius_inc_per_rad + ins_radius_offset
        next_tcp_pose = pose_trans(ins_current_pos,ins_pose)
        next_joint_pos = get_inverse_kin(next_tcp_pose)
        servoj(next_joint_pos, 0.1, 0.1, rq_controller_time_step, 0.05, 500)
      end
    end # while loop
    if (ins_actual_radius <= max_radius ):
      ins_search_result = True
    else:
      ins_search_result = False
      rq_spiral_not_completed = True
    end
    stopj(2)
    return ins_search_result
  
  end # insert_spiral_find_hole
  
  ####################  SPIRAL #############################
  def rq_insert_spiral_urcap(direction = "Z",
                             stop_force_threshold = 3,
                             max_radius = 0.005,
                             radius_incr = 0.0003,
                             peck_mode = False,
                             tangential_speed = 0.005,
                             compliant_insert_force_threshold = 10,
                             spiral_initial_pose_offset_name = "defaultname",
                             intelligent_approach_enabled = False):
  
    max_radius = max_radius / 1000 #TODO: change unit to meters and remove this line
    radius_incr = radius_incr / 1000 #TODO: change unit to meters and remove this line
  
    if (rq_insertion_force_node_id == -1):
      create_all_insertion_nodes()
    end
  
    hole_found = False
    spiral_bottom_target_reached = False
    number_of_failed_spiral_tries = 0
    number_of_spiral_tries_max = 5
    max_position_deviation = max_radius
  
    # define the direction sign from rq_ins_destination
    current_pose = get_actual_tcp_pose()
    rq_actual_to_destination = pose_trans(pose_inv(current_pose), rq_ins_destination)
    axis = str_at(direction, 0)
    direction_sign = 1
    direction = str_cat(axis,"+")
    if axis == "X":
      axis_index = 0
    elif axis == "Y":
      axis_index = 1
    elif axis == "Z":
      axis_index = 2
    else:
      textmsg("spiral insert, invalid direction ", direction)
    end
    if (rq_actual_to_destination[axis_index] < 0):
      direction_sign = -1
      direction = str_cat(axis,"-")
    end
  
    # linearsearch param
    lin_search_stop_force_threshold = compliant_insert_force_threshold
    spiral_initial_pose = get_actual_tcp_pose()
    if intelligent_approach_enabled:
      #adjust position using previous succesfull insertion final position
      spiral_initial_pose_offset = storevar.getvariablepose(spiral_initial_pose_offset_name, p[0,0,0,0,0,0])
      spiral_initial_pose_refined = pose_trans(spiral_initial_pose, spiral_initial_pose_offset)
      movel(spiral_initial_pose_refined, a = 0.1, v = 0.01)
      sleep(0.01)
    end
    while ( (spiral_bottom_target_reached == False) and (number_of_failed_spiral_tries < number_of_spiral_tries_max) ):
      rq_actual_to_destination = pose_trans(pose_inv(get_actual_tcp_pose()), rq_ins_destination)
      max_distance = norm( rq_actual_to_destination[axis_index] )
      contact_initiated = rq_linear_search_urcap(direction, lin_search_stop_force_threshold, tangential_speed, max_distance, 1)
      if contact_initiated:
        new_max_radius = determine_max_spiral_radius_from_actual_position(direction, spiral_initial_pose, max_radius)
        hole_found = insert_spiral_find_hole(axis, direction_sign, stop_force_threshold, new_max_radius, radius_incr, peck_mode, tangential_speed)
        if (hole_found == True): # if hole is found, try to insert
          max_force_control_position_deviation = determine_max_spiral_radius_from_actual_position(direction, spiral_initial_pose, max_radius)
          spiral_bottom_target_reached = insertion_compliant_move_urcap(axis, direction_sign, compliant_insert_force_threshold, tangential_speed, 1, max_force_control_position_deviation)
          if spiral_bottom_target_reached:
            if intelligent_approach_enabled:
              update_spiral_offset(direction, spiral_initial_pose, spiral_initial_pose_offset, spiral_initial_pose_offset_name) # update actual hole position.
            end
          else:
            textmsg("Insertion spiral: could not reach hole bottom")
          end
        else:
          textmsg("Insertion error: hole was not found after contact")
          break
        end
      else: # linear_search reached the teach position without contact
          spiral_bottom_target_reached = True
      end # if contact_initiated
      number_of_failed_spiral_tries = number_of_failed_spiral_tries + 1
    end # while
    return (not spiral_bottom_target_reached)
  end # rq_insert_spiral_urcap
  
  def insertion_finish_move_urcap(direction = "Z+"):
    insertion_offset = p[0,0,0,0,0,0]
    current_pose = get_actual_tcp_pose()
    rq_actual_to_destination = pose_trans(pose_inv(current_pose), rq_ins_destination)
    axis = str_at(direction, 0)
    if axis == "X":
      insertion_offset = p[rq_actual_to_destination[0],0,0,0,0,0]
    elif axis == "Y":
      insertion_offset = p[0,rq_actual_to_destination[1],0,0,0,0]
    elif axis == "Z":
      insertion_offset = p[0,0,rq_actual_to_destination[2],0,0,0]
    else:
      textmsg("insertion_finish_move_urcap, invalid direction ", direction)
    end
    insertion_pose = pose_trans(current_pose, insertion_offset)
    movel(insertion_pose, a=0.05, v=rq_ins_speed_setting)
  end
  
  def rq_xor(a, b):
    return (a and not(b)) or (not(a) and b)
  end
  
  def rq_adapt_force_control_to_direction(position_controlled_direction = 2, feature = 1, max_position_deviation = 0.1):
    force_control_enabled_vector = [True, True, True, False, False, False]
    force_control_enabled_vector[position_controlled_direction] = False
    targetForce = [0, 0, 0, 0, 0, 0]
    max_negative_deviation_vector = [-max_position_deviation, -max_position_deviation, -max_position_deviation, 0, 0, 0]
    max_positive_deviation_vector = [max_position_deviation, max_position_deviation, max_position_deviation, 0, 0, 0]
    max_negative_deviation_vector[position_controlled_direction] = 0
    max_positive_deviation_vector[position_controlled_direction] = 0
    adaptiveStiffness = True
    setup_force_node_on_server(rq_insertion_force_node_id,
                               feature, targetForce,
                               force_control_enabled_vector,
                               max_negative_deviation_vector,
                               max_positive_deviation_vector,
                               adaptiveStiffness)
  end
  
  def initialise_force_node(position_controlled_direction = 2, feature = 1, max_position_deviation = 0.1):
    movej(get_actual_joint_positions()) # This moveJ is used to prevent "another thread is already controlling the robot error".
    rq_adapt_force_control_to_direction(position_controlled_direction = position_controlled_direction,
                                        feature = 1,
                                        max_position_deviation = max_position_deviation)
    set_servoj_node_cmd(get_actual_joint_positions())
    reset_node_executor()
    active_and_reset_node(rq_insertion_force_node_id)
    active_and_reset_node(rq_insertion_servoj_node_id)
    node_execution_thread = run execute_node_thread()
    return node_execution_thread
  end
  
  ####################  ROTATIONAL #############################
  def rq_insert_rotation_urcap(positive_rotation_desired = True,
                               direction="Z",
                               speed = 0.004,
                               force_threshold = 10,
                               rotation_speed = 5,
                               max_angle_deg = 360,
                               peck_mode = False,
                               max_rotation_torque=1):
  
    speed = speed / 1000 # TODO: change speed input units to meters instead of mm and remove this line
    max_force_control_position_deviation = 0.002 # TODO: add a parameter for this in the interface
    max_torque_reached_counter_fail_threshold = 1/rq_controller_time_step # try for about one second
  
    if (rq_insertion_force_node_id == -1):
        create_all_insertion_nodes()
    end
  
    # define the direction sign
    rq_actual_to_destination = pose_trans(pose_inv(get_actual_tcp_pose()), rq_ins_destination)
    axis = str_at(direction, 0)
    direction_sign = 1
    direction = str_cat(axis,"+")
    if axis == "X":
      rq_ins_offset = p[rq_actual_to_destination[0], 0, 0, 0, 0, 0]
      rot_axe = 3
      axis_index = 0
    elif axis == "Y":
      rq_ins_offset = p[0, rq_actual_to_destination[1], 0, 0, 0, 0]
      rot_axe = 4
      axis_index = 1
    elif axis == "Z":
      rq_ins_offset = p[0, 0, rq_actual_to_destination[2], 0, 0, 0]
      rot_axe = 5
      axis_index = 2
    else:
      textmsg("insertion: invalid direction ", direction)
    end
    if (rq_actual_to_destination[axis_index] < 0):
      direction_sign = -1
      direction = str_cat(axis,"-")
      positive_rotation_desired = not positive_rotation_desired
    end
  
    distance_to_destination = norm( rq_actual_to_destination[axis_index] )
  
    contact_with_piece_initiated = rq_linear_search_urcap(direction, force_threshold, speed, distance_to_destination, feature = 1)
  
    if( contact_with_piece_initiated ):
  
      # verify validity of user inputs
      if ((rotation_speed <= 0) or (rotation_speed > 60)):
        popup("rotation speed parameter in degrees / second must be between 0.01 and 60","ERROR rq_insert_rotation_urcap")
        halt
      elif ((max_rotation_torque < 0.01) or (max_rotation_torque > 15)):
        popup("max_rotation_torque parameter in Newton-meter must be between 0.01 and 15","ERROR rq_insert_rotation_urcap")
        halt
      elif ((max_angle_deg <= 1) or (max_angle_deg > 360)):
        popup("max angle parameter in degree must be between 1 and 360","ERROR rq_insert_rotation_urcap")
        halt
      end
  
      # initialize forcenode: adapt to direction
      node_execution_thread = initialise_force_node(position_controlled_direction = axis_index,
                                                    feature = 1,
                                                    max_position_deviation = max_force_control_position_deviation)
  
      if positive_rotation_desired:
        rot_direction_sign = 1
      else:
        rot_direction_sign = -1
      end
      rq_ins_speed_setting = speed
      posrot = p[0,0,0,0,0,0]
      max_rot_angle = d2r(max_angle_deg)
      time_step_signed = rq_controller_time_step * rot_direction_sign * direction_sign
      rot_step = d2r(rotation_speed) * time_step_signed
      rot_step_5deg_per_second = d2r(5) * time_step_signed
  
      line_step = rq_ins_speed_setting * rq_controller_time_step * direction_sign
      rot_actual_angle = 0
      rot_actual_mode = 1 #1= linear, 2 = rotation
      rot_actual_distance = 0
      ins_rotation_initial_pose = get_actual_tcp_pose()
      rq_actual_to_destination = pose_trans( pose_inv(ins_rotation_initial_pose), rq_ins_destination )
      distance_to_destination = norm( rq_actual_to_destination[axis_index] )
      global rq_insertion_max_torque_reached_counter = 0
  
      if peck_mode:
        #peck mode
        positive_rotation_computed = positive_rotation_desired
        while ( (norm(rot_actual_distance) < distance_to_destination) and
                (norm(rot_actual_angle) <= max_rot_angle) and
                (rq_insertion_max_torque_reached_counter < max_torque_reached_counter_fail_threshold) ):
          is_max_torque_reached = norm(get_applied_tcp_force(rot_axe)) > max_rotation_torque
          if (ins_actual_force_urcap(direction) >= force_threshold):
            #goes up
            posrot[axis_index] = rot_actual_distance - 0.002 * direction_sign
            next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
            next_joint_pos = get_inverse_kin(next_tcp_pose)
            node_rpc_server.movejdefinewaypoint(rq_insertion_movej_node_id, next_joint_pos, 0.4, 0.4)
            execute_node(rq_insertion_movej_node_id, False )
            #rotate
            rot_actual_angle = compute_rotation_next_angle(rot_actual_angle, 285 * rot_step, is_max_torque_reached) # value of 285 define the peck mode "step size". determined ad oc
            posrot[rot_axe] = rot_actual_angle
            next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
            next_joint_pos = get_inverse_kin(next_tcp_pose)
            node_rpc_server.movejdefinewaypoint(rq_insertion_movej_node_id, next_joint_pos, 1, 1)
            execute_node(rq_insertion_movej_node_id, False )
            #go back in touch with the part
            posrot[axis_index] = rot_actual_distance
            next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
            next_joint_pos = get_inverse_kin(next_tcp_pose)
            node_rpc_server.movejdefinewaypoint(rq_insertion_movej_node_id, next_joint_pos, 0.4, 0.3)
            execute_node(rq_insertion_movej_node_id, False )
            sleep(0.1)
          else:
            rq_insertion_max_torque_reached_counter = 0
            rot_actual_distance = rot_actual_distance + line_step
            posrot[axis_index] = rot_actual_distance
            next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
            next_joint_pos = get_inverse_kin(next_tcp_pose)
            update_servoj_node_target(next_joint_pos)
            if (rq_active_node != rq_insertion_servoj_node_id):
              active_and_reset_node(rq_insertion_servoj_node_id)
            end
          end # if
        end # while
      else:
        #normal mode
        while ( (norm(rot_actual_distance) <= distance_to_destination) and
                (norm(rot_actual_angle) <= max_rot_angle) and
                (rq_insertion_max_torque_reached_counter < max_torque_reached_counter_fail_threshold) ):
          is_max_torque_reached = norm(get_applied_tcp_force(rot_axe)) > max_rotation_torque
          if ( norm(get_applied_tcp_force(axis_index)) >= force_threshold ):
            if (rot_actual_mode == 1):
              rot_actual_distance = rot_actual_distance - line_step
              posrot[axis_index] = rot_actual_distance
            end
            limited_rotation_step = limit_rotation_step_when_close_to_max_angle(rot_step, rot_step_5deg_per_second, max_rot_angle, rot_actual_angle)
            rot_actual_angle = compute_rotation_next_angle(rot_actual_angle, limited_rotation_step, is_max_torque_reached)
            posrot[rot_axe] = rot_actual_angle
            rot_actual_mode = 2
          else:
            rq_insertion_max_torque_reached_counter = 0
            rot_actual_distance = rot_actual_distance + line_step
            posrot[axis_index] = rot_actual_distance
            rot_actual_mode = 1
          end # if
          next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
          next_joint_pos = get_inverse_kin(next_tcp_pose)
          update_servoj_node_target(next_joint_pos)
        end # while
      end # if peck_mode
  
      kill_thread( node_execution_thread )
      stopj(2)
      rq_rotation_not_completed = ( (norm(rot_actual_angle) > max_rot_angle) or
                                    (rq_insertion_max_torque_reached_counter >= max_torque_reached_counter_fail_threshold) )
    else: # initial find_surface was unsuccessfull, assume a direct hit to target, which is a success
      rq_rotation_not_completed = False
    end # if contact_with_piece_initiated
  
    return rq_rotation_not_completed
  end # insert rotation 2
  
  def limit_rotation_step_when_close_to_max_angle(rot_step, minimal_rot_step, max_rot_angle, rot_actual_angle):
    rot_deceleration_angle_distance = d2r(3)
    rot_direction = 1
    if( rot_step < 0 ):
      rot_direction = -1
      rot_step = -1 * rot_step # get positive rot_step for calculation. Direction sign is re-introduced at the end.
    end
    angle_distance_to_max_rot_angle = max_rot_angle - norm(rot_actual_angle)
    if( (angle_distance_to_max_rot_angle < rot_deceleration_angle_distance) and (rot_step > minimal_rot_step) ):
      decelaration_slope = (rot_step - minimal_rot_step) / rot_deceleration_angle_distance
      rot_step_limited = decelaration_slope * angle_distance_to_max_rot_angle + minimal_rot_step
    else:
      rot_step_limited = rot_step
    end
    return ( rot_direction * rot_step_limited )
  end
  
  def compute_rotation_next_angle(current_angle, step, is_max_torque_reached):
  #This function compute the rotation angle for rotational insertion by
  # incrementing the current angle by the desired step size.
  # If the maximal torque is reached, the rotation goes backward to
  # return to a admissible torque. In the backward direction,
  # a smaller step size is used to prevent constant oscillation between to steps
    if (is_max_torque_reached):
        rq_insertion_max_torque_reached_counter = rq_insertion_max_torque_reached_counter + 1
        new_angle = current_angle - 0.8 * step
    else:
        new_angle = current_angle + step
    end
    return new_angle
  end
  
  def center_one_axis(axis, lin_search_stop_force_threshold, speed, max_distance, feature):
    # Initiate contact in forward direction
    contact_initiated = rq_linear_search_urcap( str_cat(axis, "+"), lin_search_stop_force_threshold, speed, max_distance, feature)
    if contact_initiated:
      forward_contact_pose = get_actual_tcp_pose()
      # Initiate contact in reverse direction
      contact_initiated = rq_linear_search_urcap(str_cat(axis, "-"), lin_search_stop_force_threshold, speed, max_distance, feature)
      if contact_initiated:
        reverse_contact_pose = get_actual_tcp_pose()
        # Go to average of contact points
        pose_center_1 = interpolate_pose(forward_contact_pose, reverse_contact_pose, 0.5)
        movel(pose_center_1, a=0.6, v=speed)
      end
    end
    return contact_initiated
  end
  
  def rq_insert_recenter_urcap(axis = "Z", max_distance = 0.1, speed = 0.005, feature = 1, lin_search_stop_force_threshold = 5):
  
    if (max_distance < 0) or (max_distance > 1):
      popup("max_distance parameter in m must be between 0 and 1","ERROR rq_insert_recenter_urcap")
      halt
    elif (speed < 0.0001) or (speed > 0.5):
      popup("max_radius parameter in mm must be between 0.0001m/s and 0.5m/s","ERROR rq_insert_recenter_urcap")
      halt
    end
  
    #--------------------------------------------------------------------------------------------------------------------
    #For insertion in the X axis
    #--------------------------------------------------------------------------------------------------------------------
    if (axis == "X"):
      recenter_axis_1 = "Y"
      recenter_axis_2 = "Z"
    #--------------------------------------------------------------------------------------------------------------------
    #For insertion in the Y axis
    #--------------------------------------------------------------------------------------------------------------------
    elif (axis == "Y"):
      recenter_axis_1 = "X"
      recenter_axis_2 = "Z"
    #--------------------------------------------------------------------------------------------------------------------
    #For insertion in the Z axis
    #--------------------------------------------------------------------------------------------------------------------
    elif (axis == "Z"):
      recenter_axis_1 = "X"
      recenter_axis_2 = "Y"
    end
  
    recenter_successfull = center_one_axis(recenter_axis_1, lin_search_stop_force_threshold, speed, max_distance, feature)
    if recenter_successfull:
      recenter_successfull = center_one_axis(recenter_axis_2, lin_search_stop_force_threshold, speed, max_distance, feature)
    end
  
    if (recenter_successfull == False):
      textmsg("rq_insert_recenter_urcap failed, could not initiate contact with piece")
    end
  
    return recenter_successfull
  end # rq_insert_recenter_urcap
  
  # ******************* MAIN of Insertion Preamble *******************
  storevar.clearall()
  global rq_insertion_force_node_id = -1
  def rq_linear_search_common_validation(abs_max_distance, speed, force_threshold):
    if (abs_max_distance > 2.0):
      popup("maximum distance parameter in meters must be between 0 and 2.0","ERROR rq_linear_search_urcap")
      halt
    elif (speed < 0.0001) or (speed > 0.15):
      popup("speed parameter in mm/s must be between 0.1 and 150","ERROR rq_linear_search_urcap")
      halt
    elif (force_threshold < 0.0) or (force_threshold > 200):
      popup("Force parameter in Newtons must be between 0 and 200","ERROR rq_linear_search_urcap")
      halt
    end
  end
  
  def rq_linear_search_get_direction_sign(direction):
    sign = str_at(direction, 1)
    direction_sign = 1
    if sign == "-":
      direction_sign = -1
    end
    return direction_sign
  end
  
  def rq_linear_search_get_force_index(direction):
    axis = str_at(direction, 0)
    force_index = 0
    if (axis == "X") or (axis == "x"):
      force_index = 0
    elif (axis == "Y") or (axis == "y"):
      force_index = 1
    elif (axis == "Z") or (axis == "z"):
      force_index = 2
    else:
      popup("direction parameter must be X+, X-, Y+, Y-, Z+ or Z-","ERROR rq_linear_search_urcap")
      halt
    end
    return force_index
  end
  
  def rq_linear_search_get_pose_offset(force_index, max_distance):
    pose_offset = p[0,0,0,0,0,0]
    pose_offset[force_index] = max_distance
    return pose_offset
  end
  
  def rq_linear_search_execution(pose_from, pose_to, force_threshold, speed, T_tcp_to_force_frame, force_index, direction_sign):
    steptime = rq_controller_time_step
    distance = point_dist(pose_from, pose_to)
    number_pose_interpolate = floor(distance / (speed * steptime)) + 1
    delta_alpha = 1.0 / number_pose_interpolate
  
    alpha = 0.0
    local surface_found = False
  
    pose_step = 0
    end_pose_pause_time = 0.2 # to refine
    max_pose_steps = number_pose_interpolate + end_pose_pause_time/steptime
    while (pose_step < max_pose_steps) and (not surface_found):
      pose_step = pose_step + 1
      alpha = pose_step * delta_alpha
      if (alpha < 1.0):
        pose_interpolate = interpolate_pose(pose_from, pose_to, alpha)
      else:
        pose_interpolate = pose_to
      end
  
      servoj(get_inverse_kin(pose_interpolate), 0.1, 0.1, steptime, 0.05, 500)
  
      wrench = express_force_in_frame(T_tcp_to_force_frame, tcp_wrench)
      applied_force = -1 * wrench[force_index]
  
      if (direction_sign * applied_force) >= force_threshold:
        surface_found = True
      end
    end
  
    return surface_found
  end
  
  #************************************************
  #Function:  rq_linear_search_urcap(direction="Z+", force[N] = 10, speed[m/s] = 0.004, max_distance[m] = 0.02)
  #   Find a specific force in the direction of "direction".
  #   Robot will move towards a max_distance from the current position in the tool frame
  #   Return True if the force is detected during the robot motion
  #
  #************************************************
  def rq_linear_search_urcap(direction="Z+", force_threshold = 10, speed = 0.004, max_distance = 0.02, feature = 0 ):
  
    rq_linear_search_common_validation(max_distance, speed, force_threshold)
    if (feature != 0) and (feature != 1):
      popup("feature value should be 0 for base or 1 for tool","ERROR rq_linear_search_urcap")
      halt
    end
  
    feature_base = 0
    feature_tool = 1
  
    force_index = rq_linear_search_get_force_index(direction)
    direction_sign = rq_linear_search_get_direction_sign(direction)
    max_distance = direction_sign * max_distance
    pose_offset = rq_linear_search_get_pose_offset(force_index, max_distance)
  
    tcp_pose = get_actual_tcp_pose()
    pose_from = tcp_pose
    pose_to = pose_from
    if feature == feature_base:
      pose_to = pose_add(pose_from, pose_offset)
    elif feature == feature_tool:
      pose_to = pose_trans(pose_from, pose_offset)
    end
  
    T_tcp_to_force_frame = p[0, 0, 0, 0, 0, 0] # default for feature_tool
    if (feature == feature_base):
      T_tcp_to_force_frame = pose_inv(tcp_pose)
    end
  
    surface_found = rq_linear_search_execution(pose_from, pose_to, force_threshold, speed, T_tcp_to_force_frame, force_index, direction_sign)
  
    return surface_found
  end
  
  def rq_linear_search_custom_frame(direction="Z+", force_threshold = 10, speed = 0.004, abs_max_distance = 0.02, feature_frame = p[0, 0, 0, 0, 0, 0]):
  
    rq_linear_search_common_validation(abs_max_distance, speed, force_threshold)
  
    force_index = rq_linear_search_get_force_index(direction)
    direction_sign = rq_linear_search_get_direction_sign(direction)
    max_distance = direction_sign * abs_max_distance
    pose_offset = rq_linear_search_get_pose_offset(force_index, max_distance)
  
    tcp_pose = get_actual_tcp_pose()
    offset_frame = p[tcp_pose[0], tcp_pose[1], tcp_pose[2], feature_frame[3], feature_frame[4], feature_frame[5]]
    tcp_position_with_offset = pose_trans(offset_frame, pose_offset)
    pose_from = tcp_pose
    pose_to = p[tcp_position_with_offset[0], tcp_position_with_offset[1], tcp_position_with_offset[2], tcp_pose[3], tcp_pose[4], tcp_pose[5]]
  
    T_tcp_to_force_frame = pose_trans(pose_inv(tcp_pose), feature_frame)
  
    surface_found = rq_linear_search_execution(pose_from, pose_to, force_threshold, speed, T_tcp_to_force_frame, force_index, direction_sign)
  
    return surface_found
  end
  
  def validate_wait_for_force_drop_common_parameters(force_threshold, timeout_seconds):
    if (timeout_seconds < 0.0) or (timeout_seconds > 3600):
      popup("timeout parameter in s must be between 0 and 3600","ERROR rq_wait_for_force_drop")
      halt
    elif (force_threshold < 0.0) or (force_threshold > 200):
      popup("Force parameter in Newtons must be between 0 and 200","ERROR rq_wait_for_force_drop")
      halt
    end
  end
  
  def rq_wait_for_force_drop_execution(force_threshold, T_tcp_to_force_frame, force_index, direction_sign, timeout_seconds):
    local steptime = get_steptime()
    local release_detected = False
    local time = 0
  
    while (time < timeout_seconds) and (not release_detected):
      time = time + steptime
  
      local wrench = express_force_in_frame(T_tcp_to_force_frame, tcp_wrench)
      local force = -1 * wrench[force_index]
  
      if (direction_sign * force) < force_threshold:
        release_detected = True
      end
      sync()
    end
  
    return release_detected
  end
  
  def rq_wait_for_force_drop_custom_frame(direction="Z+", force_threshold = 10, timeout_seconds = 60, feature_frame = p[0, 0, 0, 0, 0, 0] ):
    validate_wait_for_force_drop_common_parameters(force_threshold, timeout_seconds)
  
    local force_index = rq_linear_search_get_force_index(direction)
    local direction_sign = rq_linear_search_get_direction_sign(direction)
  
    local tcp_pose = get_actual_tcp_pose()
    local T_tcp_to_force_frame = pose_trans(pose_inv(tcp_pose), feature_frame)
  
    local release_detected = rq_wait_for_force_drop_execution(force_threshold, T_tcp_to_force_frame, force_index, direction_sign, timeout_seconds)
  
    return release_detected
  end
  
  def rq_wait_for_force_drop(direction="Z+", force_threshold = 10, timeout_seconds = 60, feature = 0 ):
    validate_wait_for_force_drop_common_parameters(force_threshold, timeout_seconds)
    if (feature != 0) and (feature != 1):
      popup("feature value should be 0 for base or 1 for tool","ERROR rq_wait_for_force_drop")
      halt
    end
  
    local force_index = rq_linear_search_get_force_index(direction)
    local direction_sign = rq_linear_search_get_direction_sign(direction)
  
    local feature_base = 0
    local feature_tool = 1
    local tcp_pose = get_actual_tcp_pose()
    local T_tcp_to_force_frame = p[0, 0, 0, 0, 0, 0] # default for feature_tool
    if (feature == feature_base):
      T_tcp_to_force_frame = pose_inv(tcp_pose)
    end
  
    local release_detected = rq_wait_for_force_drop_execution(force_threshold, T_tcp_to_force_frame, force_index, direction_sign, timeout_seconds)
  
    return release_detected
  end
  
  
  
    ##############################################
    # OFFSET FEATURE-RELATED VARIABLES AND METHODS
    ##############################################
    def cross_product(vector1,vector2):
      v_temp=[0,0,0]
      v_temp[0]=vector1[1]*vector2[2]-vector1[2]*vector2[1]
      v_temp[1]=vector1[2]*vector2[0]-vector1[0]*vector2[2]
      v_temp[2]=vector1[0]*vector2[1]-vector1[1]*vector2[0]
      return v_temp
    end
  
    def relocate_xyzr(init_feature, init_touch_pose, touch_pose):
      init_touch_pose_2_init_feature = pose_trans( pose_inv(init_touch_pose), init_feature)
      new_feature = pose_trans( touch_pose, init_touch_pose_2_init_feature )
  
      return new_feature
    end
  
    def relocate_orientation(touch1_init_pose, touch2_init_pose, feature_init_pose, touch1_pose, touch2_pose):
      #when relocating using 2 touch, the center of rotation is around touch point 1 (this could be changed)
  
      # initial touch2 pose in initial touch 1 pose frame:
      touch2_initial_pose_in_touch1_initial_pose_frame = pose_trans(pose_inv(touch1_init_pose), touch2_init_pose)
  
      # find theoric touch2_pose if no rotation
      touch2_pose_if_no_rotation = pose_trans(touch1_pose, touch2_initial_pose_in_touch1_initial_pose_frame)
  
      # vectors touch1 to touch2
      touch1_pose_to_touch2_pose = pose_trans(pose_inv(touch1_pose), touch2_pose)
      touch1_pose_to_touch2_pose_if_no_rotation = pose_trans(pose_inv(touch1_pose), touch2_pose_if_no_rotation)
  
      #angle axis calculation
      normal_vector = cross_product(touch1_pose_to_touch2_pose_if_no_rotation, touch1_pose_to_touch2_pose)
      normal_vector_norm = norm(normal_vector)
      if (normal_vector_norm > 10e-6):
        rotation_angle_rad = asin( normal_vector_norm / (norm(touch1_pose_to_touch2_pose_if_no_rotation) * norm(touch1_pose_to_touch2_pose) ) )
        normal_vector_to_angle_axis_multiply_norm_factor = rotation_angle_rad / normal_vector_norm
        angle_axis = [normal_vector[0] * normal_vector_to_angle_axis_multiply_norm_factor, normal_vector[1] * normal_vector_to_angle_axis_multiply_norm_factor, normal_vector[2] * normal_vector_to_angle_axis_multiply_norm_factor]
        rotation_offset_pose = p[0, 0, 0, angle_axis[0], angle_axis[1], angle_axis[2]]
  
        #rotate touch1 pose using touch2 information
        touch1_pose_rotated = pose_trans(touch1_pose, rotation_offset_pose)
      else:
        touch1_pose_rotated = touch1_pose
      end
  
      # relocate the feature using touch1_rotated_pose
      return relocate_xyzr(feature_init_pose, touch1_init_pose, touch1_pose_rotated)
    end
  
    def relocate_1_touch(touch_init_pose, touch_pose, feature_init_pose, feature_actual_pose):
      touch_initial_pose_in_initial_feature_frame = pose_trans(pose_inv(feature_init_pose), touch_init_pose)
      touch_actual_pose_in_actual_feature_frame = pose_trans(pose_inv(feature_actual_pose), touch_pose)
  
      # difference between touch poses in their respective feature frame
      touch_pose_offset = pose_sub(touch_actual_pose_in_actual_feature_frame, touch_initial_pose_in_initial_feature_frame)
  
      # remove all rotation from offset
      touch_pose_offset[3] = 0
      touch_pose_offset[4] = 0
      touch_pose_offset[5] = 0
  
      # apply pose offset to actual feature
      return pose_trans(feature_actual_pose, touch_pose_offset)
    end
    ##############################################
    # PALLETIZER INITIALIZATION
    ##############################################
    if(not palletizerXmlRpcClient.acknowledgePalletStates()):
      checkForScriptPreparationException()
      halt
    end
  
    ##############################################
    # PALLETIZER-RELATED VARIABLES AND METHODS
    ##############################################
    def rq_is_last_box_of_layer(box_id, end_of_layer_boxes, is_depalletizing):
      number_of_layers = length(end_of_layer_boxes)
      if is_depalletizing:
        boxes_on_pallet = end_of_layer_boxes[number_of_layers - 1] - box_id
      else:
        boxes_on_pallet = box_id
      end
      i = 0
      while i < number_of_layers:
        if boxes_on_pallet == end_of_layer_boxes[i]:
          return True
          break
        end
        i = i + 1
      end
      return False
    end
  
    palletizerXmlRpcClient.setCurrentPalletizerNode("")
  
    def rq_get_nb_processed_boxes():
      rq_palletizer_uuid = palletizerXmlRpcClient.getCurrentPalletizerNode()
      if rq_palletizer_uuid == "":
        popup("rq_get_nb_processed_boxes() should only be called from within a Palletizer node.", title="Palletizer", error=True, blocking=True)
        halt
      end
  
      rq_box_count = palletizerXmlRpcClient.getCurrentBoxCount(rq_palletizer_uuid)
      if rq_box_count == -1:
        popup("Invalid Palletizer node id used for rq_get_nb_processed_boxes()", title="Palletizer", error=True, blocking=True)
        halt
      end
      return rq_box_count
    end
  
    def rq_set_pallet_completed():
      rq_palletizer_uuid = palletizerXmlRpcClient.getCurrentPalletizerNode()
      if rq_palletizer_uuid == "":
        popup("rq_set_pallet_completed() should only be called from within a Palletizer node.", title="Palletizer", error=True, blocking=True)
        halt
      end
  
      palletizerXmlRpcClient.skipToAfterPallet(rq_palletizer_uuid)
    end
  
    def rq_demo_mode_switch_palletizer_mode():
      palletizerXmlRpcClient.demoModeFakePalletSwapAndAndSwitchPalletizerMode()
    end
  
    def rq_linear_axis_scan(halt_on_error=True):
      local succeeded = False
      local error_message = ""
  
      if not node_rpc_server.linearaxisconnected():
        succeeded = node_rpc_server.linearaxisscan()
        if succeeded:
          textmsg("Linear axis scanned successfully")
        else:
          error_message = "rq_linear_axis_scan() was unable to find linear axis"
        end
      else:
        succeeded = True
        textmsg("Linear axis already connected")
      end
  
      if not succeeded:
        if halt_on_error:
          popup(error_message, title="Linear Axis", error=True, blocking=True)
          halt
        else:
          textmsg(error_message)
        end
      end
  
      return succeeded
    end
  
    def rq_linear_axis_start(halt_on_error=True):
      local succeeded = False
      local error_message = ""
  
      if not node_rpc_server.linearaxisconnected():
        error_message = "rq_linear_axis_start() was unable to start linear axis : linear axis not connected"
      else:
        succeeded = node_rpc_server.linearaxisstart()
        if succeeded:
          textmsg("Linear axis started successfully")
        else:
          error_message = "rq_linear_axis_start() was unable to start linear axis"
        end
      end
  
      if not succeeded:
        if halt_on_error:
          popup(error_message, title="Linear Axis", error=True, blocking=True)
          halt
        else:
          textmsg(error_message)
        end
      end
  
      return succeeded
    end
  
    def rq_linear_axis_disable(halt_on_error=True):
      local succeeded = False
      local error_message = ""
  
      if not node_rpc_server.linearaxisconnected():
        error_message = "rq_linear_axis_disable() was unable to disable linear axis : linear axis not connected"
      else:
        succeeded = node_rpc_server.linearaxisdisable()
        if succeeded:
          textmsg("Linear axis disabled successfully")
        else:
          error_message = "rq_linear_axis_disable() was unable to disable linear axis"
        end
      end
  
      if not succeeded:
        if halt_on_error:
          popup(error_message, title="Linear Axis", error=True, blocking=True)
          halt
        else:
          textmsg(error_message)
        end
      end
  
      return succeeded
    end
  
    global rq_palletizer_state_changed = False
    def rq_set_palletizer_state(palletizer_index, processed_boxes, next_step, other_pallet_state="INACTIVE", current_pallet="CURRENT"):
      palletizerXmlRpcClient.setPalletizerState(palletizer_index, processed_boxes, next_step, other_pallet_state, current_pallet)
      checkForScriptPreparationException()
      rq_palletizer_state_changed = True
    end
  
    def rq_get_pallet_state(is_pallet_left):
      return node_rpc_server.getPalletState(is_pallet_left)
    end
    ###############################################################
    # Linear Axis Move related methods
    ###############################################################
    def verify_is_in_linear_axis_range(target_axis_position):
      axis_position_range = node_rpc_server.linearaxisgetpositionrange()
  
      if target_axis_position < axis_position_range[0] or target_axis_position > axis_position_range[1]:
        textmsg("Linear axis target position : ", target_axis_position)
        textmsg("Linear axis position range : ", axis_position_range)
        popup("Linear axis position is unreachable.", "Linear Axis Move", blocking=True, error=True)
        halt
      end
    end
  
    def rq_get_linear_axis_pos():
        axis_position = node_rpc_server.linearaxisgetactualposition()
        textmsg("Linear axis actual position : ", axis_position)
        return axis_position
    end
  
  BLOW_OFF_MODE_NO_AIR = 0
  BLOW_OFF_MODE_SMART_AIR = 1
  UNDEFINED_THREAD_ID = -1
  MODBUS_TYPE = "MODBUS"
  STANDARD_TYPE = "STANDARD"
  INVALID_OUTPUT_ADDRESS = -1
  RQ_UNUSED_TIMEOUT = -1
  
  global rq_cnc_insertion_node_ids = [-1, -1]
  global rq_run_timeout = 30
  
  ###################################################################################
  #
  # Generic methods
  #
  ###################################################################################
  
  def bool_to_str(value):
    if value:
      return "true"
    else:
      return "false"
    end
  end
  
  def bool_array_to_string(array, index):
    if (index >= length(array)):
      return "]"
    end
  
    separator = ","
    if (index == length(array) - 1):
      separator = ""
    end
  
    if (index == 0):
      str_array = concat("[", bool_to_str(array[index]), separator)
      return str_cat(str_array, bool_array_to_string(array, index + 1))
    else:
      return concat(bool_to_str(array[index]), separator, bool_array_to_string(array, index + 1))
    end
  end
  
  def rq_bool_array_to_string(array):
    return bool_array_to_string(array, 0)
  end
  
  def json_force_node(force, max_negative_deviation, max_positive_deviation, stiffness, enabled_axis, feature, is_adaptive):
    json = "{"
    json = concat(json, key_val("forceFrame", feature), ",")
    json = concat(json, key_val("isAdaptive", is_adaptive), ",")
    json = concat(json, key_val("isForceControlAboutActualPosition", "false"), ",")
    json = concat(json, key_val("isForceMode", enabled_axis), ",")
    json = concat(json, key_val("maxNegativeDeviation", max_negative_deviation), ",")
    json = concat(json, key_val("maxPositiveDeviation", max_positive_deviation), ",")
    json = concat(json, key_val("stiffness", stiffness), ",")
    json = concat(json, key_val("targetTcpWrench", force), "}")
    return json
  end
  
  def rq_setup_machine_tending_force_node(feature, force, stiffness, max_negative_deviation, max_positive_deviation, enabled_axis, is_adaptive):
    force_node_id = node_rpc_server.createnewforcenode()
    node_rpc_server.fromjson(force_node_id, json_force_node(force, max_negative_deviation, max_positive_deviation, stiffness, enabled_axis, 1, is_adaptive))
    return force_node_id
  end
  
  ###################################################################################
  #
  # TRAJECTORY UTILITIES
  #
  ###################################################################################
  
  def dot_product(v1, v2):
    return [v1]*transpose(v2)
  end
  
  def get_symmetric_poses_from_middle(p1, p2, middle_pose, distance):
    distance_p1_middle = point_dist(p1, middle_pose)
    alpha = (distance / 2) / distance_p1_middle
    start_pose = interpolate_pose(middle_pose, p1, alpha)
    end_pose = interpolate_pose(middle_pose, p2, alpha)
  
    return [start_pose, end_pose]
  end
  
  def translate_to_origin(pose):
    return p[0, 0, 0, pose[3], pose[4], pose[5]]
  end
  
  
  ###################################################################################
  #
  # ROBOTIQ PART PRESENTER
  #
  ###################################################################################
  
  global cnc_part_presenter_index = 0
  
  def rq_pallet_get_poses_from_index(p_corner_1_approach, p_corners, nb_rows, nb_columns, alternate_direction, index):
      row = floor(index / nb_columns)
      column = index % nb_columns
  
      row_alpha = 0
      if(nb_rows > 1):
          row_alpha = row / (nb_rows - 1)
      end
  
      p_row_start = interpolate_pose(p_corners[0], p_corners[3], row_alpha)
      p_row_end = interpolate_pose(p_corners[1], p_corners[2], row_alpha)
  
      column_alpha = 0
      if(nb_columns > 1):
          column_alpha = column / (nb_columns - 1)
      end
  
      if(alternate_direction and (row % 2) and nb_columns > 1):
          pallet_pose = interpolate_pose(p_row_end, p_row_start, column_alpha)
      else:
          pallet_pose = interpolate_pose(p_row_start, p_row_end, column_alpha)
      end
  
      T_1approach_1 = pose_trans(inv(p_corner_1_approach), p_corners[0])
      approach_pose = pose_trans(pallet_pose, inv(T_1approach_1))
  
      return [approach_pose, pallet_pose]
  end
  
  ###################################################################################
  #
  # MOVE DOOR
  #
  ###################################################################################
  
  def rq_setup_door_force_node(reference_frame, force, stiffness):
    feature = 1
    forces = [force,0,0,0,0,0]
    max_negative_deviation = [-5, 0, 0, 0, 0, 0]
    max_positive_deviation = [0.01, 0, 0, 0, 0, 0] # using a large value here would allow the trajectory to violate the kinematics limits, using zero removes the force node effect
    stiffnesses = [stiffness, 100, 100, 100, 100, 100]
    enabled_axis = [True, False, False, False, False, False]
    is_adaptive = True
  
    force_node_id = rq_setup_machine_tending_force_node(feature, forces, stiffnesses, max_negative_deviation, max_positive_deviation, enabled_axis, is_adaptive)
  
    node_rpc_server.setCustomFixedForceFrame(force_node_id, [reference_frame[3],reference_frame[4],reference_frame[5]])
  
    return force_node_id
  end
  
  def json_rq_moves_node(tcp_speed, tcp_accel):
    json = "{"
    json = concat(json, key_val("offsetType", 0), ",")
    json = concat(json, key_val("tcpSpeed", tcp_speed), ",")
    json = concat(json, key_val("tcpAccel", tcp_accel), ",")
    json = concat(json, key_val("actualreferenceframe", [0, 0, 0, 0, 0, 0]), ",")
    json = concat(json, key_val("originalreferenceframe", [0, 0, 0, 0, 0, 0]), "}")
    return json
  end
  
  def rq_setup_rqmoves_node(parent_node_id, tcp_speed, tcp_accel):
    rq_moves_node_id = node_rpc_server.createnewrqmoves()
    node_rpc_server.fromjson(rq_moves_node_id, json_rq_moves_node(tcp_speed, tcp_accel))
    node_rpc_server.setparentid(rq_moves_node_id, parent_node_id)
    return rq_moves_node_id
  end
  
  def rq_setup_waypoint_node(pose, joints, is_straight, parent_node_id):
    def json_waypoint_node(pose, joints, is_straight):
      json = "{"
      json = concat(json, key_val("jointPositions", joints), ",")
      json = concat(json, key_val("tcpPose", [pose[0],pose[1],pose[2],pose[3],pose[4],pose[5]]), ",")
      json = concat(json, key_val("isStraight", bool_to_str(is_straight)), "}")
      return json
    end
  
    waypoint_node_id = node_rpc_server.createnewwaypointnode()
    node_rpc_server.fromjson(waypoint_node_id, json_waypoint_node(pose, joints, is_straight))
    node_rpc_server.setparentid(waypoint_node_id, parent_node_id)
    node_rpc_server.rqmovesaddwaypoint(parent_node_id, waypoint_node_id)
    return waypoint_node_id
  end
  
  def rq_setup_move_door(reference_frame, start_pose, start_joints, stop_pose, stop_joints, move_force, contact_force, tcp_speed=0.4, tcp_accel=0.4):
  
    stop_pose_in_start_frame = pose_trans(pose_inv(start_pose), stop_pose)
  
    seeks_contact = False
    stiffness = 10
    move_force_node_id = rq_setup_door_force_node(reference_frame, move_force, stiffness)
    rq_moves_node_id = rq_setup_rqmoves_node(move_force_node_id, tcp_speed, tcp_accel)
    waypoint_open = rq_setup_waypoint_node(start_pose, start_joints, False, rq_moves_node_id)
    waypoint_close = rq_setup_waypoint_node(stop_pose, stop_joints, True, rq_moves_node_id)
    seeks_contact = True
    stiffness = 100
    contact_force_node_id = rq_setup_door_force_node(reference_frame, contact_force, stiffness)
  
    rq_movej_node_id = node_rpc_server.createnewmovejnode()
    node_rpc_server.setparentid(rq_movej_node_id, move_force_node_id)
  
    return [move_force_node_id, rq_moves_node_id, waypoint_open, waypoint_close, contact_force_node_id, rq_movej_node_id]
  end
  
  def rq_move_door(start_pose, start_joints, stop_pose, stop_joints, move_force, contact_force, tcp_speed, tcp_accel, approach_pose, approach_joints, end_reached_threshold=0.001):
  
    reference_frame = list_to_pose(kinematics_rpc_server.reorientP1WithXTowardP2andZApproxP1Z(start_pose, stop_pose))
  
    node_ids = rq_setup_move_door(reference_frame, start_pose, start_joints, stop_pose, stop_joints, move_force, contact_force, tcp_speed, tcp_accel)
  
    move_force_node_id = node_ids[0]
    rq_moves_node_id = node_ids[1]
    start_waypoint_node_id = node_ids[2]
    end_waypoint_node_id = node_ids[3]
    contact_force_node_id = node_ids[4]
    rq_movej_node_id = node_ids[5]
  
    rq_wait_ft_sensor_steady(2000)
    rq_ft_sensor_disconnected_check()
    rq_zero_sensor()
    sleep(0.1)
  
    path_answer = node_rpc_server.rqmovesinit(rq_moves_node_id)
    verify_path_answer(path_answer)
  
    approach_position_joints = get_inverse_kin(approach_pose, qnear=approach_joints)
    movej(approach_position_joints)
  
    node_rpc_server.movejdefinewaypoint(rq_movej_node_id, get_actual_joint_positions(), 1.0, 1.0)
    node_rpc_server.setparentid(rq_movej_node_id, move_force_node_id)
    reset_node_executor()
    active_and_reset_node(move_force_node_id)
    node_execution_thread = execute_node(rq_movej_node_id, True)
  
    path_answer = node_rpc_server.rqmovesinit(rq_moves_node_id)
    verify_path_answer(path_answer)
    q0 = node_rpc_server.rqmovesgetfirstpoint(rq_moves_node_id)
    node_rpc_server.setparentid(rq_movej_node_id, move_force_node_id)
    node_rpc_server.movejdefinewaypoint(rq_movej_node_id, q0, 1.0, 0.4)
    execute_node(rq_movej_node_id)
    execute_node(start_waypoint_node_id)
    execute_node(end_waypoint_node_id)
  
    kill_thread(node_execution_thread)
  
    node_rpc_server.movejdefinewaypoint(rq_movej_node_id, get_actual_joint_positions(), 1.0, 1.0)
    node_rpc_server.setparentid(rq_movej_node_id, contact_force_node_id)
    reset_node_executor()
    active_and_reset_node(contact_force_node_id)
    node_execution_thread = execute_node(rq_movej_node_id, True)
  
    timeout = 20
    while (point_dist(get_actual_tcp_pose(), stop_pose) > end_reached_threshold):
      if (timeout <= 0):
        popup("Door has not reached its final position")
        halt
      else:
        sync()
        timeout = timeout - get_steptime()
      end
    end
  
    kill_thread(node_execution_thread)
  
    approach_pose_in_start_frame = pose_trans(pose_inv(start_pose), approach_pose)
    retract_pose = pose_trans(get_actual_tcp_pose(), approach_pose_in_start_frame)
    movej(retract_pose)
  
    node_rpc_server.deletenode(move_force_node_id)
    node_rpc_server.deletenode(rq_moves_node_id)
    node_rpc_server.deletenode(start_waypoint_node_id)
    node_rpc_server.deletenode(end_waypoint_node_id)
    node_rpc_server.deletenode(contact_force_node_id)
    node_rpc_server.deletenode(rq_movej_node_id)
  
  end
  
  ###################################################################################
  #
  # CNC Insertion
  #
  ###################################################################################
  
  def rq_collet_insertion(contact_pose, insert_pose, inserted_pose):
      movel(contact_pose, a=1.2, v=0.025)
      movel(insert_pose, a=1.2, v=0.025)
  
      rq_ft_sensor_disconnected_check()
      rq_zero_sensor()
      sleep(0.1)
  
      direction = "Z+"
      stop_force_threshold = 3.0
      max_radius = 5.0
      radius_incr = 0.7
      peck_mode = False
      tangential_speed = 0.02
      compliant_insert_force_threshold = 10.0
      spiral_initial_pose_offset_name = "spiral_initial_pose_offset_name"
      rq_ins_destination = inserted_pose
      max_distance = point_dist(inserted_pose, get_actual_tcp_pose())
      rq_spiral_not_completed = False
      rq_ins_speed_setting = 0.02
  
      rq_insert_spiral_urcap(direction, stop_force_threshold, max_radius, radius_incr, peck_mode, tangential_speed, compliant_insert_force_threshold, spiral_initial_pose_offset_name)
  
      if (rq_spiral_not_completed):
        return False
      end
  
      return True
  end
  
  def rq_push_part(approach_pose, chuck_pose):
      rq_ft_sensor_disconnected_check()
      rq_zero_sensor()
      sleep(0.1)
  
      # Find pose with z axis pointing in the direction of the insertion
      p1 = translate_to_origin(approach_pose)
      insertion_dir_in_base_frame = pose_trans(p1, pose_trans(pose_inv(approach_pose), chuck_pose))
      ref_frame_pose = list_to_pose(kinematics_rpc_server.poseFromZaxis([insertion_dir_in_base_frame[0], insertion_dir_in_base_frame[1], insertion_dir_in_base_frame[2]]))
  
      surface_found = rq_linear_search_custom_frame("Z+", 10.0, 0.025, 0.1, ref_frame_pose)
  
      if not(surface_found):
          return False
      end
  
      return True
  end
  
  def rq_place_in_chuck(close_chuck_do, open_chuck_do, chuck_approach, chuck_position, chuck_delay):
      rq_open_workholding(close_chuck_do, open_chuck_do)
  
      movel(chuck_approach, a=1.2, v=0.25)
      movel(chuck_position, a=1.2, v=0.25)
  
      rq_close_workholding(close_chuck_do, open_chuck_do)
      sleep(chuck_delay)
  end
  
  def rq_pre_pick_in_chuck(chuck_approach, chuck_position, speed=0.25, accel=1.2):
      movel(chuck_approach, accel, speed)
      movel(chuck_position, accel, speed)
  end
  
  def rq_post_pick_in_chuck(close_chuck_do, open_chuck_do, chuck_approach, chuck_position, chuck_delay, speed=0.25,
  accel=1.2):
      rq_open_workholding(close_chuck_do, open_chuck_do)
      sleep(chuck_delay)
  
      movel(chuck_approach, accel, speed)
  end
  
  def rq_open_workholding(close_do, open_do):
      rq_set_workholding_do(close_do, open_do, False)
  end
  
  def rq_close_workholding(close_do, open_do):
      rq_set_workholding_do(close_do, open_do, True)
  end
  
  def rq_set_workholding_do(close_do, open_do, close_request):
      is_close_do_valid = rq_is_do_valid(close_do)
      is_open_do_valid = rq_is_do_valid(open_do)
  
      if(is_close_do_valid):
          set_standard_digital_out(close_do, close_request)
      end
      if(is_open_do_valid):
          set_standard_digital_out(open_do, not close_request)
      end
      if(is_close_do_valid or is_open_do_valid):
          sleep(0.5)
      end
  end
  
  def rq_is_do_valid(do_id):
      return do_id >= 0 and do_id <= 7
  end
  
  def set_cleaning_digital_output(address, state, blow_off_mode, output_type):
     if(blow_off_mode == BLOW_OFF_MODE_SMART_AIR):
       rq_set_output(output_type, address, state)
     end
  end
  
  ###################################################################################
  #
  # PATH GENERATOR 6 POINTS CURVE BUILT WITH 2 POINTS
  #
  ###################################################################################
  
  def execute_half_pipe(pose_1, pose_2,pose_transformation_air_nozzle_to_actual_tcp, depth, length_distance, width, angle, speed, spacing, address, output_type, blow_off_mode, passes):
    path_gen_poses = get_path_generator_6_points_poses(pose_1, pose_2, pose_transformation_air_nozzle_to_actual_tcp, depth, length_distance, width, angle)
    start_pose = p[path_gen_poses[0,0],path_gen_poses[0,1],path_gen_poses[0,2],path_gen_poses[0,3],path_gen_poses[0,4],path_gen_poses[0,5]]
    path_generator_node_id = setup_path_generator_6_points(path_gen_poses, speed, spacing)
    execute_path_generator_6_points(path_generator_node_id, start_pose,  address, output_type, blow_off_mode, passes)
  end
  
  def get_path_generator_6_points_poses(pose_2, pose_5,pose_transformation_air_nozzle_to_actual_tcp, depth=0.01, length=0, width=0.05, angle_deg=0):
  
    def offset_pose(pose, offset, offset_reference_frame, pose_transformation_air_nozzle_to_actual_tcp):
      pose_relative_to_ref_frame = express_pose_A_relative_to_pose_B(pose, offset_reference_frame)
      ref_frame_with_offset = pose_trans(offset_reference_frame, offset)
      pose_with_offset = pose_trans(ref_frame_with_offset, pose_relative_to_ref_frame)
      pose_with_offset_for_actual_tcp = pose_trans(pose_with_offset, pose_transformation_air_nozzle_to_actual_tcp)
      return pose_to_list(pose_with_offset_for_actual_tcp)
    end
  
    if(length > 0):
      middle_pose = interpolate_pose(pose_2, pose_5, 0.5)
  
      poses = get_symmetric_poses_from_middle(pose_2, pose_5, middle_pose, length)
      pose_2 = poses[0]
      pose_5 = poses[1]
    end
  
    path_ref_frame = list_to_pose(kinematics_rpc_server.reorientP1WithXTowardP2andZApproxP1Z(pose_2, pose_5))
  
    offset1 = pose_add(p[0,0,0,0,d2r(angle_deg),0], p[0, width,-depth,-d2r(angle_deg),0,0])
    offset2 = pose_add(p[0,0,0,0,d2r(angle_deg),0], p[0,     0,     0,              0,0,0])
    offset3 = pose_add(p[0,0,0,0,d2r(angle_deg),0], p[0,-width,-depth, d2r(angle_deg),0,0])
  
    pose_1_array = offset_pose(pose_2, offset1, path_ref_frame, pose_transformation_air_nozzle_to_actual_tcp)
    pose_2_array = offset_pose(pose_2, offset2, path_ref_frame, pose_transformation_air_nozzle_to_actual_tcp)
    pose_3_array = offset_pose(pose_2, offset3, path_ref_frame, pose_transformation_air_nozzle_to_actual_tcp)
  
    pose_4_array = offset_pose(pose_5, offset1, path_ref_frame, pose_transformation_air_nozzle_to_actual_tcp)
    pose_5_array = offset_pose(pose_5, offset2, path_ref_frame, pose_transformation_air_nozzle_to_actual_tcp)
    pose_6_array = offset_pose(pose_5, offset3, path_ref_frame, pose_transformation_air_nozzle_to_actual_tcp)
  
    return [pose_1_array, pose_2_array, pose_3_array, pose_4_array, pose_5_array, pose_6_array]
  end
  
  def setup_path_generator_6_points(pose_list, tcp_speed=0.1, spacing=0.02):
  
    def json_path_generator_node(pose_list, tcp_speed, spacing):
  
      SIX_POINTS_CURVE = 3
      OFFSET_TYPE_NONE = 0
      FORCE_OPPOSITE_SIDE = 2
  
      json = "{"
      json = concat(json, key_val("tcpSpeed", tcp_speed), ",")
      json = concat(json, key_val("poses", pose_list), ",")
      json = concat(json, key_val("avoidAbruptEnd", "false"), ",")
      json = concat(json, key_val("isSurfaceFillOn", "true"), ",")
      json = concat(json, key_val("spacing", spacing), ",")
      json = concat(json, key_val("pathType", SIX_POINTS_CURVE), ",")
      json = concat(json, key_val("offsetType",OFFSET_TYPE_NONE), ",")
      json = concat(json, key_val("endingMode", FORCE_OPPOSITE_SIDE), "}")
  
      return json
    end
  
    rq_path_generator_parent_id = 0
    path_generator_node_id = node_rpc_server.createPathGeneratorNode()
    node_rpc_server.fromjson(path_generator_node_id, json_path_generator_node(pose_list, tcp_speed, spacing))
    node_rpc_server.setparentid(path_generator_node_id, rq_path_generator_parent_id)
  
    return path_generator_node_id
  end
  
  def execute_path_generator_6_points(path_generator_node_id, pose_1, address = INVALID_OUTPUT_ADDRESS, output_type = MODBUS_TYPE, blow_off_mode = BLOW_OFF_MODE_NO_AIR, passes = 1):
    index = 0
    while (index < passes):
      movej(get_inverse_kin(pose_1))
      set_cleaning_digital_output(address, True, blow_off_mode, output_type)
      reset_node_executor()
      node_execution_thread = execute_node(path_generator_node_id, True)
      rq_continue_node_execution = False
      set_cleaning_digital_output(address, False, blow_off_mode, output_type)
      join node_execution_thread
      index = index + 1
    end
    node_rpc_server.deletenode(path_generator_node_id)
  end
  
  ###################################################################################
  #
  # Straight line trajectory
  #
  ###################################################################################
  
  def execute_straight_line(p1, p2,pose_transformation_air_nozzle_to_actual_tcp, accel=1.2, speed=0.25, distance = 0, angles = [0, 0, 0], address = INVALID_OUTPUT_ADDRESS, output_type = MODBUS_TYPE, blow_off_mode = BLOW_OFF_MODE_NO_AIR, passes = 1):
    offset_for_angles = p[0, 0, 0, d2r(angles[0]), d2r(angles[1]), d2r(angles[2])]
    p1 = pose_trans(p1, offset_for_angles)
    p2 = pose_trans(p2, offset_for_angles)
  
    # apply transformation to take into account that the actual tcp offset is not the same as the one that was used when the waypoints were saved:
    p1 = pose_trans(p1, pose_transformation_air_nozzle_to_actual_tcp)
    p2 = pose_trans(p2, pose_transformation_air_nozzle_to_actual_tcp)
    global air_output_adress = address
  
    qActual = get_actual_joint_positions()
    CleanPathId = node_rpc_server.createnewcleaningpathnode(p1, p2, qActual, passes, distance, accel, speed, blow_off_mode)
  
    reset_node_executor()
    if output_type == MODBUS_TYPE:
      air_thread = run modbusAirControlThread()
    elif output_type == STANDARD_TYPE:
      air_thread = run standardAirControlThread()
    end
  
    node_execution_thread = execute_node(CleanPathId, True)
    rq_continue_node_execution = False
  
    join node_execution_thread
    node_rpc_server.deletenode(CleanPathId)
    if output_type == MODBUS_TYPE or output_type == STANDARD_TYPE :
      kill air_thread
    end
  end
  
  ###################################################################################
  #
  # Cross trajectory
  #
  ###################################################################################
  
  def find_cross_trajectory_poses(p1, p2, height=0, width=0, p1_angles = [0, 0, 0], p2_angles = [0, 0, 0], p3_angles = [0, 0, 0], p4_angles = [0, 0, 0]):
    def find_side_poses(p0, p1):
      def find_side_pose(p0,p1,angle):
        p1_T_p0 = pose_trans(pose_inv(p0), p1)
        rotated_p0_by_90_degrees = pose_trans(p0, p[0, 0, 0, 0, 0, d2r(angle)])
  
        side_pose = pose_trans(rotated_p0_by_90_degrees, p1_T_p0)
        side_pose[3] = p0[3]
        side_pose[4] = p0[4]
        side_pose[5] = p0[5]
  
        return side_pose
      end
  
      p3= find_side_pose(p0, p1, 90)
      p4 = find_side_pose(p0, p1, 270)
  
      return [p3, p4]
    end
  
    def get_start_and_end_poses_based_on_distance(p1, p2, middle_pose, distance):
      if(distance == 0):
        start_pose = p1
        end_pose = p2
      else:
        poses = get_symmetric_poses_from_middle(p1, p2, middle_pose, distance)
        start_pose = poses[0]
        end_pose = poses[1]
      end
      return [start_pose, end_pose]
    end
  
    def get_side_poses_based_on_distance(p1, p2, middle_pose, width):
      if(width == 0):
        side_poses = find_side_poses(middle_pose, p1)
      else:
        poses = get_symmetric_poses_from_middle(p1, p2, middle_pose, width)
        side_poses = find_side_poses(middle_pose, poses[0])
      end
  
      return side_poses
    end
  
    def get_angle_offset(angles):
      return  p[0, 0, 0, d2r(angles[0]), d2r(angles[1]), d2r(angles[2])]
    end
  
    middle_pose = interpolate_pose(p1, p2, 0.5)
  
    start_and_end_poses = get_start_and_end_poses_based_on_distance(p1, p2, middle_pose, height)
    side_poses = get_side_poses_based_on_distance(p1, p2, middle_pose, width)
  
    p1_offset = get_angle_offset(p1_angles)
    p2_offset = get_angle_offset(p2_angles)
    p3_offset = get_angle_offset(p3_angles)
    p4_offset = get_angle_offset(p4_angles)
  
    start_and_end_poses[0] = pose_trans(start_and_end_poses[0], p1_offset)
    start_and_end_poses[1] = pose_trans(start_and_end_poses[1], p2_offset)
    side_poses[0] = pose_trans(side_poses[0], p3_offset)
    side_poses[1] = pose_trans(side_poses[1], p4_offset)
  
    return [middle_pose, start_and_end_poses[0], start_and_end_poses[1], side_poses[0], side_poses[1]]
  end
  
  def execute_cross_trajectory(p1, p2,pose_transformation_air_nozzle_to_actual_tcp, height=0, width=0, p1_angles = [0, 0, 0], p2_angles = [0, 0, 0], p3_angles = [0, 0, 0], p4_angles = [0, 0, 0], accel=1.2, speed=0.25,  address = INVALID_OUTPUT_ADDRESS, output_type = MODBUS_TYPE, blow_off_mode = BLOW_OFF_MODE_NO_AIR, passes = 1):
  
    cross_poses = find_cross_trajectory_poses(p1, p2, height, width, p1_angles, p2_angles, p3_angles, p4_angles)
  
    p0 = pose_trans(cross_poses[0], pose_transformation_air_nozzle_to_actual_tcp)
    p1 = pose_trans(cross_poses[1], pose_transformation_air_nozzle_to_actual_tcp)
    p2 = pose_trans(cross_poses[2], pose_transformation_air_nozzle_to_actual_tcp)
    p3 = pose_trans(cross_poses[3], pose_transformation_air_nozzle_to_actual_tcp)
    p4 = pose_trans(cross_poses[4], pose_transformation_air_nozzle_to_actual_tcp)
  
   index = 0
  
   while (index < passes):
     movej(get_inverse_kin(p0))
     set_cleaning_digital_output(address, True, blow_off_mode, output_type)
     movel(p1, accel, speed)
     movel(p2, accel, speed)
     movel(p0, accel, speed)
     movel(p3, accel, speed)
     movel(p4, accel, speed)
     set_cleaning_digital_output(address, False, blow_off_mode, output_type)
     index = index + 1
   end
  end
  
  def execute_waypoint_cross_trajectory(starting_pose, finishing_pose, accel=1.2, speed=0.25):
   movej(get_inverse_kin(starting_pose))
   movel(finishing_pose, accel, speed)
  end
  
  ###################################################################################
  #
  # Fermat spiral trajectory
  #
  ###################################################################################
  
  def execute_fermat_spiral(start_pose, end_pose,pose_transformation_air_nozzle_to_actual_tcp, max_radius = 0, angle = 0, number_of_turns = 1, speed = 0.25,address = INVALID_OUTPUT_ADDRESS, output_type = MODBUS_TYPE, blow_off_mode = BLOW_OFF_MODE_NO_AIR, passes = 1):
    def find_middle(start_pose, end_pose):
      alpha = 0.5
      return interpolate_pose(start_pose, end_pose, alpha)
    end
  
    def find_next_theta(spiral_constant, theta, speed):
      denom = spiral_constant * sqrt(1/(4*theta) + theta)
      theta_dot = speed / denom
      theta = theta + theta_dot * rq_controller_time_step
      return theta
    end
  
    def find_spiral_pose(theta, spiral_plane, center_pose, angle, spiral_constant, pose_transformation_air_nozzle_to_actual_tcp):
      local r = spiral_constant * sqrt(theta)
      local x = r * cos(theta)
      local y = r * sin(theta)
  
      local p2 = pose_trans(spiral_plane, p[x,y,0,0,0,0])
      local p3 = p[p2[0], p2[1], p2[2], center_pose[3], center_pose[4], center_pose[5]]
      local p4 = pose_trans(p3, pose_transformation_air_nozzle_to_actual_tcp)
      local p5 = pose_trans(p4, p[0, 0, 0, -d2r(angle)*cos(theta), -d2r(angle)*sin(theta), 0])
      return p5
    end
  
    def execute_outer_to_inner_spiral(start_pose, middle_pose, spiral_plane, pose_transformation_air_nozzle_to_actual_tcp, max_angle, angle, spiral_constant_nominal, speed, address, output_type, blow_off_mode):
      local theta = max_angle
      local max_r = point_dist(start_pose, middle_pose)
      local spiral_constant = -1 * spiral_constant_nominal
      local r = max_r
      local is_first_pose = True
  
      while (norm((r)) <= max_r):
        theta = find_next_theta(spiral_constant, theta, speed)
        if(theta < 0):
          break
        end
  
        r = spiral_constant * sqrt(theta)
        next_pose = find_spiral_pose(theta, spiral_plane, middle_pose, angle, spiral_constant, pose_transformation_air_nozzle_to_actual_tcp)
  
        if (is_first_pose):
          movej(get_inverse_kin(next_pose))
          set_cleaning_digital_output(address, True, blow_off_mode, output_type)
          is_first_pose = False
        else:
          servoj(get_inverse_kin(next_pose), t = rq_controller_time_step)
        end
      end
    end
  
    def execute_inner_to_outer_spiral(start_pose, middle_pose, spiral_plane, pose_transformation_air_nozzle_to_actual_tcp, angle, spiral_constant, speed):
      local theta = 0.0001
      local max_r = point_dist(start_pose, middle_pose)
      local r = 0
  
      while (norm(r) <= max_r):
        theta = find_next_theta(spiral_constant, theta, speed)
        r = spiral_constant * sqrt(theta)
        next_pose = find_spiral_pose(theta, spiral_plane, middle_pose, angle, spiral_constant, pose_transformation_air_nozzle_to_actual_tcp)
        servoj(get_inverse_kin(next_pose), t = rq_controller_time_step)
      end
    end
  
    max_angle = d2r(number_of_turns * 360)
    middle_pose = find_middle(start_pose, end_pose)
  
    if(max_radius > 0):
      poses = get_symmetric_poses_from_middle(start_pose, end_pose, middle_pose, max_radius * 2)
      start_pose = poses[0]
      end_pose = poses[1]
    end
  
    SPIRAL_CONSTANT = (point_dist(middle_pose, start_pose)) / sqrt(max_angle)
  
    spiral_plane = list_to_pose(kinematics_rpc_server.reorientP1WithXTowardP2andZApproxP1Z(middle_pose, end_pose))
  
  
    index = 0
    while(index < passes):
      execute_outer_to_inner_spiral(start_pose, middle_pose, spiral_plane,pose_transformation_air_nozzle_to_actual_tcp, max_angle, angle, SPIRAL_CONSTANT, speed, address, output_type, blow_off_mode)
      execute_inner_to_outer_spiral(end_pose, middle_pose, spiral_plane, pose_transformation_air_nozzle_to_actual_tcp, angle, SPIRAL_CONSTANT, speed)
      set_cleaning_digital_output(address, False, blow_off_mode, output_type)
      index = index + 1
    end
  end
  
  ###################################################################################
  #
  # ROBOTIQ VISE INSERTION
  #
  # - The first touch is performed in the direction of the gravity, regardless of
  #   the robot mounting orientation, tcp offset and TCP orientation
  # - Optional 2e et 3e touch are performed relative to TCP. They require that, at
  #   the moment that the insertion is performed, the TCP is oriented such that one
  #   axis is aligned with the gravity. The TCP axes for the 2e and 3e touch are
  #   chosen as the ones not aligned with the gravity.
  ###################################################################################
  def insert_in_vise(start_pose, end_pose, number_of_touch=3, forces=[10, 20, 20], invert_axis=False, move_to_end_pose=False):
  
    def list_by_scalar_multiply_(l1, scalar):
      result = l1
      i=0
      while i<length(result):
        result[i]=l1[i]*scalar
        i=i+1
      end
      return result
    end
  
    def find_gravity_direction(acceleration_direction, threshold):
      result = [False, False, False]
      i = 0
      while i < length(result):
        result[i] =  norm(acceleration_direction[i]) > threshold
        i = i + 1
      end
      return result
    end
  
    def get_axis(index, direction):
      axis = "XYZ"
      if direction < 0:
        sign = "-"
      elif direction > 0:
        sign = "+"
      else:
        popup("insert_in_vise:get_axis >>> direction cannot be 0. Fix it.")
        halt
      end
      return str_cat(str_sub(axis, index, 1), sign)
    end
  
    def direction_to_index(str):
      if "X" == str_sub(str, 0, 1):
        return 0
      elif "Y" == str_sub(str, 0, 1):
        return 1
      elif "Z" == str_sub(str, 0, 1):
        return 2
      else:
        popup("invalid direction :", str)
        halt
      end
    end
  
    def find_touch_direction(mask, direction):
      i = 0
      result = [0, 0, 0]
      while i < 3:
        if mask[i]:
          result[i] = direction[i]
        end
        i = i + 1
      end
      return result
    end
  
    def find_touch_direction_str(mask, direction):
      i = 0
      result = ""
      while i < 3:
        if mask[i]:
          result = str_cat(result, get_axis(i, direction[i]))
        end
        i = i + 1
      end
      return result
    end
  
    def invert(list):
      result = list
      i = 0
      while i < length(list):
        result[i] = not list[i]
        i = i + 1
      end
      return result
    end
  
    def assert_that_the_first_touch_is_aligned_with_an_axis(first_touch_direction_mask):
      i = 0
      counter = 0
      while i < length(first_touch_direction_mask):
        if first_touch_direction_mask[i]:
          counter = counter + 1
        end
        i = i + 1
      end
  
      if counter != 1:
        popup("One of the TCP axes must be perpendicular to the floor while loading the part in the vise.")
        halt
      end
    end
  
    def setup_nodes(forces, number_of_touch, first_touch_direction_mask, direction, second_direction_str, third_direction_str):
      def max_deviation_from(forces, enabled_axis):
        i = 0
        deviation = [0, 0, 0, 0, 0, 0]
        while i < 3:
          if forces[i] > 0:
            deviation[i] = 10
          elif forces[i] ==  0:
            deviation[i] = 10
          end
          i = i + 1
        end
        while i < 6:
          if enabled_axis[i]:
            deviation[i] = 0.35
          end
          i = i + 1
        end
        return deviation
      end
  
      def min_deviation_from(forces, enabled_axis):
        i = 0
        deviation = [0, 0, 0, 0, 0, 0]
        while i < 3:
          if forces[i] < 0:
            deviation[i] = -10
          elif forces[i] ==  0:
            deviation[i] = -10
          end
          i = i + 1
        end
        while i < 6:
          if enabled_axis[i]:
            deviation[i] = -0.35
          end
          i = i + 1
        end
        return deviation
      end
  
      def stiffness_from(forces):
        i = 0
        stiffness = [0, 0, 0, 100, 100, 100]
        while i < length(forces):
          if norm(forces[i]) > 0:
            stiffness[i] = 100
          else:
            stiffness[i] = 85
          end
          i = i + 1
        end
        return stiffness
      end
  
      def compute_final_forces(forces, number_of_touch, first_touch_direction_mask, direction, second_direction_str, third_direction_str):
        final_forces = [0, 0, 0]
        if number_of_touch > 0:
          i = 0
          while i < length(first_touch_direction_mask):
            if first_touch_direction_mask[i]:
              break
            end
            i = i + 1
          end
          final_forces[i] = direction[i] * forces[i]
        end
        if number_of_touch > 1:
          i = direction_to_index(second_direction_str)
          final_forces[i] = direction[i] * forces[i]
        end
        if number_of_touch > 2:
          i = direction_to_index(third_direction_str)
          final_forces[i] = direction[i] * forces[i]
        end
        return final_forces
      end
  
      def compute_enabled_axis(first_touch_direction_mask):
        enabled_axis = [True, True, True, False, False, False]
        i = 0
        while i < length(first_touch_direction_mask):
          if first_touch_direction_mask[i]:
            break
          end
          i = i + 1
        end
        enabled_axis[i + 3] = True
  
        return enabled_axis
      end
  
      final_forces = compute_final_forces(forces, number_of_touch, first_touch_direction_mask, direction, second_direction_str, third_direction_str)
      enabled_axis = compute_enabled_axis(first_touch_direction_mask)
  
      force_node_id = rq_setup_machine_tending_force_node(1, [final_forces[0], final_forces[1], final_forces[2], 0, 0, 0], stiffness_from
      (final_forces), min_deviation_from(final_forces, enabled_axis), max_deviation_from(final_forces, enabled_axis), rq_bool_array_to_string(enabled_axis), "false")
      movej_node_id = node_rpc_server.createnewmovejnode()
      node_rpc_server.setparentid(movej_node_id, force_node_id)
  
      return [force_node_id, movej_node_id]
    end
  
    def average_tool_acceleration_reading(n_samples, delay):
      n = n_samples
      reading = [0, 0, 0]
      while n > 0:
        reading = reading + get_tool_accelerometer_reading()
        sleep(delay)
        n = n - 1
      end
      return reading/n_samples
    end
  
    def linear_search_toward_gravity(force):
      # maybe add a stopj here to prevent acceleration reading to be influenced by robot movement
      flange_accel = average_tool_acceleration_reading(10, 0.1) # measured accel is oriented in gravity oposite direction
      flange_accel_pose = p[-flange_accel[0], -flange_accel[1], -flange_accel[2], 0, 0,0]
      p1 = translate_to_origin(get_actual_tool_flange_pose())
      gravity_dir_in_base_frame = pose_trans(p1, flange_accel_pose)
  
      # Find pose with z axis pointing in gravity direction:
      ref_frame_pose = list_to_pose(kinematics_rpc_server.poseFromZaxis([gravity_dir_in_base_frame[0], gravity_dir_in_base_frame[1], gravity_dir_in_base_frame[2]]))
      speed = 0.01
      abs_max_distance = 0.05
  
      surface_found = rq_linear_search_custom_frame("Z+", force, speed, abs_max_distance, ref_frame_pose)
      return surface_found
    end
  
    #### Actual insert_in_vise method ####
    movel(start_pose)
    zero_ftsensor()
  
    # 1. Use accelerometer reading to find touches directions:
    ACCELERATION_THRESHOLD = 8
    flange_accel = average_tool_acceleration_reading(10, 0.1)
    tcp_accel = pose_trans(pose_inv(get_tcp_offset()), p[flange_accel[0], flange_accel[1], flange_accel[2], 0, 0, 0])
    first_touch_direction_mask = find_gravity_direction(tcp_accel, ACCELERATION_THRESHOLD)
    assert_that_the_first_touch_is_aligned_with_an_axis(first_touch_direction_mask)
  
    direction_transform = pose_trans(pose_inv(start_pose), end_pose)
    direction = [direction_transform[0], direction_transform[1], direction_transform[2]]
    direction_sign = [direction[0]/norm(direction[0]), direction[1]/norm(direction[1]), direction[2]/norm(direction[2])]
  
    touch_direction_str = find_touch_direction_str(invert(first_touch_direction_mask), direction_sign)
    touch_direction = find_touch_direction(invert(first_touch_direction_mask), direction_sign)
  
    if invert_axis:
      second_direction_str = str_sub(touch_direction_str, 0, 2)
      third_direction_str = str_sub(touch_direction_str, 2, 4)
    else:
      second_direction_str = str_sub(touch_direction_str, 2, 4)
      third_direction_str = str_sub(touch_direction_str, 0, 2)
    end
  
    end_pose_orientation = translate_to_origin(end_pose)
  
    # 2. Prepare nodes:
    rq_cnc_insertion_node_ids = setup_nodes(forces, number_of_touch, first_touch_direction_mask, direction_sign, second_direction_str, third_direction_str)
    feature_tool = 1
  
    # 3. Perform touches:
    if number_of_touch > 0:
      surface_found = linear_search_toward_gravity(forces[0])
      if not surface_found:
        textmsg("Insertion in vise: First contact has not been found")
        popup("First contact has not been found", title="Insertion in vise", blocking=True)
        return UNDEFINED_THREAD_ID
      end
    end
    if number_of_touch > 1:
      surface_found = rq_linear_search_urcap(second_direction_str, forces[1], 0.01, 0.05, feature_tool)
      if not surface_found:
        textmsg("Insertion in vise: Second contact has not been found")
        popup("Second contact has not been found", title="Insertion in vise", blocking=True)
        return UNDEFINED_THREAD_ID
      end
    end
    if number_of_touch > 2:
      surface_found = rq_linear_search_urcap(third_direction_str, forces[2], 0.01, 0.05, feature_tool)
      if not surface_found:
        textmsg("Insertion in vise: Third contact has not been found")
        popup("Third contact has not been found", title="Insertion in vise", blocking=True)
        return UNDEFINED_THREAD_ID
      end
    end
  
    # 4. Move to end position:
    if not move_to_end_pose:
      end_pose = get_actual_tcp_pose()
    end
  
    node_rpc_server.movejdefinewaypoint(rq_cnc_insertion_node_ids[1], get_actual_joint_positions(), 1.0, 1.0)
    reset_node_executor()
    active_and_reset_node(rq_cnc_insertion_node_ids[0])
    node_execution_thread = execute_node(rq_cnc_insertion_node_ids[1], True)
    node_rpc_server.movejdefinewaypoint(rq_cnc_insertion_node_ids[1], get_inverse_kin(end_pose), 1.0, 1.0)
    execute_node(rq_cnc_insertion_node_ids[1])
    sleep(1)
    return node_execution_thread
  end
  
  ###################################################################################
  # AIR OUTPUT CONTROL
  ###################################################################################
  thread modbusAirControlThread():
    while (True):
      rq_air_value = read_input_boolean_register(101)
      modbus_set_output_signal(air_output_adress, rq_air_value, False)
      sleep(rq_controller_time_step)
    end
  end
  
  thread standardAirControlThread():
    while (True):
      rq_air_value = read_input_boolean_register(101)
      set_digital_out(air_output_adress, rq_air_value)
      sleep(rq_controller_time_step)
    end
  end
  def rq_set_output(output_type, address, value):
    if output_type == "MODBUS":
      modbus_set_output_signal(address, value)
    elif output_type == "STANDARD":
      set_standard_digital_out(address, value)
    end
  end
  
  def rq_digital_output_action(action, output_type, address, time_on=1, time_off=0.5, delay_after=0):
    if action == "PUSH_AND_HOLD":
      rq_set_output(output_type, address, True)
    elif action == "PUSH":
      rq_set_output(output_type, address, True)
      sleep(time_on)
      rq_set_output(output_type, address, False)
    elif action == "DOUBLE_PUSH":
      rq_set_output(output_type, address, True)
      sleep(time_on)
      rq_set_output(output_type, address, False)
      sleep(time_off)
      rq_set_output(output_type, address, True)
      sleep(time_on)
      rq_set_output(output_type, address, False)
    elif action == "RELEASE":
      rq_set_output(output_type, address, False)
    end
    sleep(delay_after)
  end
  def json_kinematic_parameters_ratio(ratio):
    json = "{"
    json = concat(json, key_val("kinematicParametersRatio", ratio), "}")
    return json
  end
  
  def execute_move_along_trail(trail_node_id, joint_positions, kinematic_parameters_ratio):
    node_rpc_server.fromjson(trail_node_id, json_kinematic_parameters_ratio(kinematic_parameters_ratio))
    roadmap_state = node_rpc_server.initRoadmap(trail_node_id, joint_positions)
    path_time = roadmap_state[0]
  
    if(path_time > 0.0):
      reset_node_executor()
      node_execution_thread = execute_node(trail_node_id, True)
      kill node_execution_thread
    end
  end
    global servojId = 2
  rq_collision_detection_start(60.0,10.0, False)
  # end: URCap Installation Node
  while (True):
    $ 1 "Robot Program"
    $ 2 "Force"
    sleep(0.02)
    force_mode(tool_pose(), [1, 1, 0, 0, 0, 0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 2, [0.2, 0.2, 0.1, 0.3490658503988659, 0.3490658503988659, 0.3490658503988659])
    $ 3 "MoveJ" "noBreak"
    $ 4 "Waypoint_1" "noBreak"
    movej(get_inverse_kin(p[-.060046291950, -.421998985427, .499953865028, 1.400200360342, -.599965858708, .299799477753], qnear=[4.9158124923706055, -1.420429531727926, -1.515679661427633, 2.9958620071411133, -1.149759594594137, 0.5700847506523132]), a=1.3962634015954636, v=1.0471975511965976)
    $ 5 "Waypoint_2" "noBreak"
    movej(get_inverse_kin(p[-.060051509053, -.562834413461, .499930927259, 1.400245929955, -.600010854p529, .299781516783], qnear=[4.855421543121338, -1.76625901857485, -1.161269489918844, 2.9859251976013184, -1.2105734984027308, 0.5739099383354187]), a=1.3962634015954636, v=1.0471975511965976)
    end_force_mode()
    stopl(5.0)
  end
end