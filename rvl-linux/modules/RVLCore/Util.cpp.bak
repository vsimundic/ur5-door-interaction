#include "RVLCore2.h"
#ifdef RVLVTK
#include "RVLVTK.h"
#include <vtkTriangle.h>
#endif
#include "Util.h"
#ifdef RVLVTK
#include "MarchingCubes.h"
#endif

#ifdef RVLLINUX
#include <Eigen/Eigenvalues>
#define RVLFILEPATH_SEPARATOR '/'
#else
#include <Eigen\Eigenvalues>
#define RVLFILEPATH_SEPARATOR '\\'
#endif

using namespace RVL;

void RVL::QuickSort(int *Key, int *Index, int n)
{
	// get range

	int *pKey = Key;

	int min = *(pKey++);
	int max = min;

	int i;

	for (i = 1; i < n; i++, pKey++)
	{
		if (*pKey < min)
			min = *pKey;
		else if (*pKey > max)
			max = *pKey;
	}

	int nBins = max - min + 1;

	// create lookup table

	Array<QList<QLIST::Index>> KeyLT;

	KeyLT.Element = new QList<QLIST::Index>[nBins];
	KeyLT.n = nBins;

	QList<QLIST::Index> *pKeyList;

	for (i = 0; i < nBins; i++)
	{
		pKeyList = KeyLT.Element + i;

		RVLQLIST_INIT(pKeyList);
	}

	QLIST::Index *KeyMem = new QLIST::Index[n];

	QLIST::Index *pKeyLTEntry = KeyMem;

	int j;

	for (i = 0; i < n; i++)
	{
		j = Key[i] - min;

		pKeyList = KeyLT.Element + j;

		RVLQLIST_ADD_ENTRY(pKeyList, pKeyLTEntry);

		pKeyLTEntry->Idx = i;

		pKeyLTEntry++;
	}

	// fill index array

	int *pIndex = Index;

	for (i = 0; i < nBins; i++)
	{
		pKeyList = KeyLT.Element + i;

		pKeyLTEntry = pKeyList->pFirst;

		while (pKeyLTEntry)
		{
			*(pIndex++) = pKeyLTEntry->Idx;

			pKeyLTEntry = pKeyLTEntry->pNext;
		}
	}

	// deallocate lookup table

	delete[] KeyLT.Element;
	delete[] KeyMem;
}

void RVL::RandomColor(unsigned char *color)
{
	color[0] = (unsigned char)(rand() % 256);
	color[1] = (unsigned char)(rand() % 256);
	color[2] = (unsigned char)(rand() % 256);
}

//VIDOVIC
bool RVL::GetAngleAxis(float *R, float *V, float &theta)
{
	float k = 0.5 * (R[0 * 3 + 0] + R[1 * 3 + 1] + R[2 * 3 + 2] - 1.0);

	if (k > 1.0)
	{
		theta = 0.0;

		return FALSE;
	}
	else if (k < -1.0)
	{
		theta = PI;

		return FALSE;
	}

	theta = acos(k);

	k = 0.5 / sin(theta);

	V[0] = k * (R[2 * 3 + 1] - R[1 * 3 + 2]);
	V[1] = k * (R[0 * 3 + 2] - R[2 * 3 + 0]);
	V[2] = k * (R[1 * 3 + 0] - R[0 * 3 + 1]);

	return TRUE;
}

void RVL::GetDistance(float *t, float &distance)
{
	distance = sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
}

void RVL::PrintMatrix(FILE *fp, double *A, int n, int m)
{
	double *pA = A;

	int i, j;

	for(i = 0; i < n; i++)
	{
		for(j = 0; j < m; j++, pA++)
			fprintf(fp, "%lf\t", *pA);

		fprintf(fp, "\n");
	}
}

void RVL::GetFileNameAndPath(
	char *fileNameWithPath,
	char *&fileName,
	char *&filePath)
{
	fileName = strrchr(fileNameWithPath, '\\') + 1;

	int fileNameLength = (int)strlen(fileName);

	int filePathLength = (int)strlen(fileNameWithPath) - fileNameLength;

	if (filePath)
	{
		if (strlen(filePath) < filePathLength)
		{
			delete[] filePath;

			filePath = new char[filePathLength + 1];
		}
	}
	else
		filePath = new char[filePathLength + 1];

	memcpy(filePath, fileNameWithPath, filePathLength);

	filePath[filePathLength] = '\0';
}

void RVL::ReadLine(
	FILE *fp,
	int nCharacters,
	char *line)
{
	fgets(line, nCharacters, fp);
	if(line[strlen(line) - 1] == 10)
		line[strlen(line) - 1] = '\0';
	if(line[strlen(line) - 1] == 13)
		line[strlen(line) - 1] = '\0';
}

FileSequenceLoader::FileSequenceLoader()
{
	nFileNames = 0;
	currentID = 0;
}

FileSequenceLoader::~FileSequenceLoader()
{
}

bool FileSequenceLoader::Init(char *sequenceFileName)
{
	FILE *fp = fopen(sequenceFileName, "r");

	if (fp)
	{
		char line[200];
		int lineCnt = 0;
		int sequenceFileNameLength;

		char *tabChar;
		char ID[5];

		while (TRUE)
		{
			//fgets(line, 200, fp);
			ReadLine(fp, 200, line);

			if (line[0] == '\n')
				continue;

			if(strlen(line) == 0)
				continue;

			if (strstr(line, "end") == line)
			{
				nFileNames = lineCnt;
				break;
			}

			lineCnt++;

			tabChar = strrchr(line, '\t');

			if (tabChar)
			{
				IDs.resize(lineCnt);

				strncpy(ID, line, strlen(line) - strlen(tabChar));

				ID[strlen(line) - strlen(tabChar)] = '\0';

				IDs[lineCnt - 1] = atoi(ID);

				strncpy(line, line + strlen(line) - strlen(tabChar) + 1, strlen(tabChar) - 1);

				line[strlen(tabChar) - 1] = '\0';
			}

			//Save model name
			names.resize(lineCnt, std::vector<char>(0));

			if (strrchr(line, RVLFILEPATH_SEPARATOR))
				//names[lineCnt - 1].assign(line + strlen(line) - strlen(strrchr(line, RVLFILEPATH_SEPARATOR)) + 1, line + strlen(line) - 1);
				names[lineCnt - 1].assign(line + strlen(line) - strlen(strrchr(line, RVLFILEPATH_SEPARATOR)) + 1, line + strlen(line));
			else
				//names[lineCnt - 1].assign(line, line + strlen(line) - 1);
				names[lineCnt - 1].assign(line, line + strlen(line));

			names[lineCnt - 1].insert(names[lineCnt - 1].end(), 1, '\0');

			//Save path
			paths.resize(lineCnt, std::vector<char>(0));

			//paths[lineCnt - 1].assign(line, line + strlen(line) - 1);
			paths[lineCnt - 1].assign(line, line + strlen(line));

			if (line[1] != ':')
			{
				sequenceFileNameLength = strlen(strrchr(sequenceFileName, RVLFILEPATH_SEPARATOR)) - 1;

				paths[lineCnt - 1].insert(paths[lineCnt - 1].begin(), sequenceFileName, sequenceFileName + strlen(sequenceFileName) - sequenceFileNameLength);
			}

			paths[lineCnt - 1].insert(paths[lineCnt - 1].end(), 1, '\0');
		}

		fclose(fp);

		currentID = 0;

		return 1;
	}
	else
		return 0;
}

bool FileSequenceLoader::Get(int index, char *filePath, char *fileName, int *ID)
{
	if (index < nFileNames)
	{
		GetFilePath(index, filePath);

		GetFileName(index, fileName);

		GetID(index, ID);

		return 1;
	}
	else
		return 0;
}

bool FileSequenceLoader::GetNext(char *filePath, char *fileName, int *ID)
{
	if (nFileNames > 0 && currentID < nFileNames)
	{
		GetFilePath(currentID, filePath);

		GetFileName(currentID, fileName);

		GetID(currentID, ID);

		currentID++;

		return 1;
	}
	else
		return 0;
}

bool FileSequenceLoader::Get(int index, char *filePath, char *fileName)
{
	if (index < nFileNames)
	{
		GetFilePath(index, filePath);

		GetFileName(index, fileName);

		return 1;
	}
	else
		return 0;
}

bool FileSequenceLoader::GetNext(char *filePath, char *fileName)
{
	if (nFileNames > 0 && currentID < nFileNames)
	{
		GetFilePath(currentID, filePath);

		GetFileName(currentID, fileName);

		currentID++;

		return 1;
	}
	else
		return 0;
}

bool FileSequenceLoader::GetFilePath(int index, char *filePath)
{
	if (index < nFileNames)
	{
		char *filePath_;
		int filePathLength;

		filePath_ = paths[index].data();

		filePathLength = paths[index].size();

		memcpy(filePath, filePath_, filePathLength);

		return 1;
	}
	else
		return 0;
}

bool FileSequenceLoader::GetNextPath(char *filePath)
{
	if (nFileNames > 0 && currentID < nFileNames)
	{
		GetFilePath(currentID, filePath);

		currentID++;

		return 1;
	}
	else
		return 0;
}

bool FileSequenceLoader::GetFileName(int index, char *fileName)
{
	if (index < nFileNames)
	{
		char *fileName_;
		int fileNameLength;

		fileName_ = names[index].data();

		fileNameLength = names[index].size();

		memcpy(fileName, fileName_, fileNameLength);

		return 1;
	}
	else
		return 0;
}

bool FileSequenceLoader::GetNextName(char *fileName)
{
	if (nFileNames > 0 && currentID < nFileNames)
	{
		GetFileName(currentID, fileName);

		currentID++;

		return 1;
	}
	else
		return 0;
}

bool FileSequenceLoader::GetID(int index, int *ID)
{
	if (index < nFileNames && IDs.size() > 0)
	{
		*ID = IDs[index];

		return 1;
	}
	else
		return 0;
}

bool FileSequenceLoader::GetNextID(int *ID)
{
	if (nFileNames > 0 && currentID < nFileNames && IDs.size() > 0)
	{
		GetID(currentID, ID);

		currentID++;

		return 1;
	}
	else
		return 0;
}

int FileSequenceLoader::GetLastModelID()
{
	if (IDs.size())
		return IDs[IDs.size() - 1];
	else
		return -1;
}

void FileSequenceLoader::ResetID()
{
	currentID = 0;
}

void FileSequenceLoader::AddModel(int ID, char *filePath, char *fileName)
{
	//Save ID
	IDs.resize(IDs.size() + 1);
	IDs[IDs.size() - 1] = ID;

	//Save model path
	paths.resize(paths.size() + 1, std::vector<char>(0));
	paths[paths.size() - 1].assign(filePath, filePath + strlen(filePath));
	paths[paths.size() - 1].insert(paths[paths.size() - 1].end(), 1, '\0');

	//Save model name
	names.resize(names.size() + 1, std::vector<char>(0));
	names[names.size() - 1].assign(fileName, fileName + strlen(fileName));
	names[names.size() - 1].insert(names[names.size() - 1].end(), 1, '\0');

	nFileNames++;
}

ECCVGTLoader::ECCVGTLoader()
{
	nScenes = 0;
	nModels = 0;
	iScene = 0;
	GT.Element = NULL;
	GT.n = 0;
	modelsInDB = NULL;
	GTFolder = NULL;
	GTFilePath = NULL;
	bRotInvariantModel = NULL;
	dataSetFlag = RVL_DATASET_FLAG_TUW_KINECT;
}

ECCVGTLoader::~ECCVGTLoader()
{
	if (GT.n > 0 && GT.Element)
	{
		int i;

		for (i = 0; i < nScenes; i++)
			RVL_DELETE_ARRAY(GT.Element[i].Element)

		RVL_DELETE_ARRAY(GT.Element);
	}
	RVL_DELETE_ARRAY(modelsInDB);
	RVL_DELETE_ARRAY(GTFolder);
	RVL_DELETE_ARRAY(GTFilePath);
	RVL_DELETE_ARRAY(bRotInvariantModel);
}

bool ECCVGTLoader::Init(char *filePath, char *GTFolderPath, char *modelsID, DWORD dataSet)
{
	if (dataSet)
		dataSetFlag = dataSet;

	nScenes = 1;

	GT.Element = new Array<GTInstance>[nScenes];
	GT.n = nScenes;

	modelsInDB = new char[strlen(modelsID) + 1];
	memcpy(modelsInDB, modelsID, strlen(modelsID));
	modelsInDB[strlen(modelsID)] = '\0';

	GTFolder = new char[strlen(GTFolderPath) + 1];
	memcpy(GTFolder, GTFolderPath, strlen(GTFolderPath));
	GTFolder[strlen(GTFolderPath)] = '\0';

	GTFilePath = new char[200];

	//Kinect dataset
	if (dataSetFlag == RVL_DATASET_FLAG_TUW_KINECT)
		CreateGTFilePath(filePath, GTFilePath);
	//Willow and Challenge dataset
	else if (dataSetFlag == RVL_DATASET_FLAG_WILLOW_AND_CHALLENGE)
		CreateWillowAndChallengeGTFilePath(filePath, GTFilePath);

	if (LoadModels(GTFilePath))
	{
		iScene++;

		return 1;
	}
	else
		return 0;
}

bool ECCVGTLoader::Init(FileSequenceLoader sceneSequence, char *GTFolderPath, char *modelsID, DWORD dataSet)
{
	if (GTFolderPath == NULL)
	{
		printf("Cannot find a GT file!\n");

		return false;
	}

	if (dataSet)
		dataSetFlag = dataSet;

	nScenes = sceneSequence.nFileNames;

	GT.Element = new Array<GTInstance>[nScenes];
	GT.n = nScenes;

	char filePath[200];

	modelsInDB = new char[strlen(modelsID) + 1];
	memcpy(modelsInDB, modelsID, strlen(modelsID));
	modelsInDB[strlen(modelsID)] = '\0';

	GTFolder = new char[strlen(GTFolderPath) + 1];
	memcpy(GTFolder, GTFolderPath, strlen(GTFolderPath));
	GTFolder[strlen(GTFolderPath)] = '\0';

	GTFilePath = new char[200];

	while (sceneSequence.GetNextPath(filePath))
	{
		//Kinect dataset
		if (dataSetFlag == RVL_DATASET_FLAG_TUW_KINECT)
			CreateGTFilePath(filePath, GTFilePath);
		//Willow and Challenge dataset
		else if (dataSetFlag == RVL_DATASET_FLAG_WILLOW_AND_CHALLENGE)
			CreateWillowAndChallengeGTFilePath(filePath, GTFilePath);
		//ICL dataset
		else if (dataSetFlag == RVL_DATASET_FLAG_ICL)
			CreateGTFilePath(filePath, GTFilePath);

		if (!LoadModels(GTFilePath))
			return false;

		iScene++;
	}

	FILE *fp = fopen((std::string(GTFolderPath) + "\\gt.dat").data(), "w");

	int nScenes = iScene;

	int iObject = 0;

	Array<GTInstance> *pGTArray;

	for (iScene = 0; iScene < nScenes; iScene++)
	{
		pGTArray = GT.Element + iScene;

		GTInstance *pGT;
		int iGT;

		for (iGT = 0; iGT < pGTArray->n; iGT++)
		{
			pGT = pGTArray->Element + iGT;

			fprintf(fp, "%d\t%d\t%d\t%f\t%f\t%f\t%f\t%f\t%f\n", iObject, iScene, pGT->iModel, pGT->t[0], pGT->t[1], pGT->t[2], pGT->R[2], pGT->R[5], pGT->R[8]);

			iObject++;
		}
	}

	fclose(fp);

	return true;
}

bool ECCVGTLoader::LoadModels(char *filePath)
{
	FILE *fp = fopen(filePath, "r");

	int nSModels;

	if (fp)
	{
		char line[200];
		int iModel, i;

		//fgets(line, 200, fp);
		ReadLine(fp, 200, line);
		fscanf(fp, "%d\n", &nSModels);
		//fgets(line, 200, fp);
		ReadLine(fp, 200, line);

		GT.Element[iScene].Element = new GTInstance[nSModels];
		GT.Element[iScene].n = nSModels;

		nModels += nSModels;

		GTInstance *pGT = GT.Element[iScene].Element;
		
		for (iModel = 0; iModel < nSModels; iModel++)
		{
			pGT->iScene = iScene;

			//fgets(line, 200, fp);
			ReadLine(fp, 200, line);

			line[strlen(line) - 1] = '\0';

			pGT->iModel = FindModelID(line);

			for (i = 0; i < 3; i++)
				fscanf(fp, "%f %f %f %f\n", &pGT->R[i * 3], &pGT->R[i * 3 + 1], &pGT->R[i * 3 + 2], &pGT->t[i]);

			if (dataSetFlag == RVL_DATASET_FLAG_TUW_KINECT)
				RVLSCALEMX3X3(pGT->R, 1000.0f, pGT->R);		// This is for TUW Kinect dataset only!

			pGT->matched = false;

			//fgets(line, 200, fp);
			//fgets(line, 200, fp);
			ReadLine(fp, 200, line);
			ReadLine(fp, 200, line);

			pGT++;
		}

		fclose(fp);

		return 1;
	}
	else
		return 0;
}

int ECCVGTLoader::FindModelID(char *modelName)
{
	//char *dbFileName = new char[50];
	char dbFileName[50];
	int index = 0;
	int ID;

	FileSequenceLoader dbLoader;
	dbLoader.Init(modelsInDB);

	while (dbLoader.GetNextName(dbFileName))
	{
		if (!strcmp(modelName, dbFileName))
		{
			dbLoader.GetID(index, &ID);
			return ID;
		}
		index++;
	}

	return -1;	
}

void ECCVGTLoader::CreateGTFilePath(char *scenePath, char *GTFilePath)
{
	int GTFileSize = strlen(GTFolder);

	int modelNameSize = strlen(strrchr(scenePath, '\\'));

	memcpy(GTFilePath, GTFolder, GTFileSize);

	memcpy(GTFilePath + GTFileSize, scenePath + strlen(scenePath) - modelNameSize, modelNameSize - 3);

	GTFileSize += modelNameSize - 3;

	memcpy(GTFilePath + GTFileSize, "txt", 3);

	GTFileSize += 3;

	memcpy(GTFilePath + GTFileSize, "\0", 1);
}

void ECCVGTLoader::CreateWillowAndChallengeGTFilePath(char *scenePath, char *GTFilePath)
{
	int GTFileSize = strlen(GTFolder);

	int modelNameSize = strlen(strrchr(scenePath, '\\')) + strlen("\\T_xx");

	memcpy(GTFilePath, GTFolder, GTFileSize);

	memcpy(GTFilePath + GTFileSize, scenePath + strlen(scenePath) - modelNameSize, modelNameSize - 3);

	GTFileSize += modelNameSize - 3;

	memcpy(GTFilePath + GTFileSize, "txt", 3);

	GTFileSize += 3;

	memcpy(GTFilePath + GTFileSize, "\0", 1);
}

bool ECCVGTLoader::SaveGTFile(char *filePath)
{
	FILE *fp;

	fp = fopen(filePath, "w");

	int iS, iM, i;

	if (fp)
	{
		GTInstance *pGT;

		for (iS = 0; iS < nScenes; iS++)
		{
			pGT = GT.Element[iS].Element;

			for (iM = 0; iM < GT.Element[iS].n; iM++)
			{
				fprintf(fp, "%d\t%d\t", pGT->iScene, pGT->iModel);

				for (i = 0; i < 9; i++)
					fprintf(fp, "%f\t", pGT->R[i]);

				for (i = 0; i < 3; i++)
					fprintf(fp, "%f\t", pGT->t[i]);

				fprintf(fp, "%d\n", (int)pGT->matched);

				pGT++;
			}
		}

		fclose(fp);

		return 1;
	}
	else
		return 0;
}

void ECCVGTLoader::ResetMatchFlag()
{
	GTInstance *pGT;

	int iModel, nModels;

	for (iScene = 0; iScene < nScenes; iScene++)
	{
		pGT = GT.Element[iScene].Element;

		nModels = GT.Element[iScene].n;

		for (iModel = 0; iModel < nModels; iModel++)
		{
			pGT->matched = false;

			pGT++;
		}
	}
}

void ECCVGTLoader::LoadRotInvarianceInfo(char *rotInvarianceFileName)
{
	if (rotInvarianceFileName == NULL)
	{
		printf("Rotation invariance model info is not available.\n");

		return;
	}

	FILE *fp = fopen(rotInvarianceFileName, "r");

	if (fp == NULL)
	{
		printf("Rotation invariance model info is not available.\n");

		return;
	}

	printf("Loading rotation invariance model info.\n");

	fscanf(fp, "%d\n", &nModelsInDB);

	RVL_DELETE_ARRAY(bRotInvariantModel);

	bRotInvariantModel = new bool[nModelsInDB];

	memset(bRotInvariantModel, 0, nModelsInDB * sizeof(bool));

	int iModel;

	while (!feof(fp))
	{
		fscanf(fp, "%d\n", &iModel);

		if (iModel >= 0 && iModel < nModelsInDB)
			bRotInvariantModel[iModel] = true;
	}

	fclose(fp);
}

//END VIDOVIC

namespace RVL
{
#ifdef RVLVTK
	vtkSmartPointer<vtkPolyData> DisplayIsoSurface(
		Array3D<float> f,
		float *P0,
		float voxelSize,
		float isolevel,
		float *W
		)
	{
		CRVLMem mem;

		mem.Create(5 * sizeof(QLIST::Entry<MCTriangle<float>>) + sizeof(BYTE *) + 1);

		QList<QLIST::Entry<MCTriangle<float>>> triangleList;

		QList<QLIST::Entry<MCTriangle<float>>> *pTriangleList = &triangleList;

		MarchingCubes MC;

		MC.ComputeTables();

		vtkSmartPointer<vtkPoints> points =
			vtkSmartPointer<vtkPoints>::New();

		vtkSmartPointer<vtkCellArray> triangles =
			vtkSmartPointer<vtkCellArray>::New();

		int nVoxels = f.a * f.b * f.c;

		int *iEdgePt[3];

		int i;

		for (i = 0; i < 3; i++)
		{
			iEdgePt[i] = new int[nVoxels];

			memset(iEdgePt[i], 0xff, nVoxels * sizeof(int));
		}

		int edgePtIdx[] = {-1, -1, -1, -1, -1, 1, 0, -1, -1, -1, 2, -1};
		int dx[12];
		int dy[12];
		int dz[12];
		int iEdge[12];

		dx[0] = 0; dy[0] = -1; dz[0] = -1; iEdge[0] = 0;
		dx[1] = 0; dy[1] = 0; dz[1] = -1; iEdge[1] = 1;
		dx[2] = 0; dy[2] = 0; dz[2] = -1; iEdge[2] = 0;
		dx[3] = -1; dy[3] = 0; dz[3] = -1; iEdge[3] = 1;
		dx[4] = 0; dy[4] = -1; dz[4] = 0; iEdge[4] = 0;
		dx[5] = 0; dy[5] = 0; dz[5] = 0; iEdge[5] = 1;
		dx[6] = 0; dy[6] = 0; dz[6] = 0; iEdge[6] = 0;
		dx[7] = -1; dy[7] = 0; dz[7] = 0; iEdge[7] = 1;
		dx[8] = -1; dy[8] = -1; dz[8] = 0; iEdge[8] = 2;
		dx[9] = 0; dy[9] = -1; dz[9] = 0; iEdge[9] = 2;
		dx[10] = 0; dy[10] = 0; dz[10] = 0; iEdge[10] = 2;
		dx[11] = -1; dy[11] = 0; dz[11] = 0; iEdge[11] = 2;

		int iTriangle = 0;

		int iPt = 0;

		int maxi = f.a - 2;
		int maxj = f.b - 2;
		int maxk = f.c - 2;

		float P[8][3];
		float F[8];
		QLIST::Entry<MCTriangle<float>> *pTriangle;
		vtkSmartPointer<vtkTriangle> triangle;
		int j, k, l;
		float x, y, z;
		int edgePtIdx_, edgeIdx;
		int iVoxel, iVoxel_, i_, j_, k_, iPt_;
		int jVoxel[8];

		for (k = 0; k <= maxk; k++)
			for (j = 0; j <= maxj; j++)
				for (i = 0; i <= maxi; i++)
				{
					x = (float)i * voxelSize + P0[0];
					y = (float)j * voxelSize + P0[1];
					z = (float)k * voxelSize + P0[2];

					iVoxel = RVL3DARRAY_INDEX(f, i, j, k);

					RVLQLIST_INIT(pTriangleList);

					jVoxel[0] = f.a * (f.b * k + j) + i;
					jVoxel[1] = f.a * (f.b * k + j) + i + 1;
					jVoxel[2] = f.a * (f.b * k + j + 1) + i + 1;
					jVoxel[3] = f.a * (f.b * k + j + 1) + i;
					jVoxel[4] = f.a * (f.b * (k + 1) + j) + i;
					jVoxel[5] = f.a * (f.b * (k + 1) + j) + i + 1;
					jVoxel[6] = f.a * (f.b * (k + 1) + j + 1) + i + 1;
					jVoxel[7] = f.a * (f.b * (k + 1) + j + 1) + i;

					RVLSET3VECTOR(P[0], x, y, z);
					RVLSET3VECTOR(P[1], x + voxelSize, y, z);
					RVLSET3VECTOR(P[2], x + voxelSize, y + voxelSize, z);
					RVLSET3VECTOR(P[3], x, y + voxelSize, z);
					RVLSET3VECTOR(P[4], x, y, z + voxelSize);
					RVLSET3VECTOR(P[5], x + voxelSize, y, z + voxelSize);
					RVLSET3VECTOR(P[6], x + voxelSize, y + voxelSize, z + voxelSize);
					RVLSET3VECTOR(P[7], x, y + voxelSize, z + voxelSize);

					F[0] = f.Element[jVoxel[0]];
					F[1] = f.Element[jVoxel[1]];
					F[2] = f.Element[jVoxel[2]];
					F[3] = f.Element[jVoxel[3]];
					F[4] = f.Element[jVoxel[4]];
					F[5] = f.Element[jVoxel[5]];
					F[6] = f.Element[jVoxel[6]];
					F[7] = f.Element[jVoxel[7]];

					MC.ComputeTriangles<float>(P, F, isolevel, pTriangleList, &mem);

					pTriangle = pTriangleList->pFirst;

					while (pTriangle)
					{
						for (l = 0; l < 3; l++)
						{
							edgePtIdx_ = edgePtIdx[pTriangle->data.idx[l]];

							if (edgePtIdx_ < 0)
								continue;

							if (iEdgePt[edgePtIdx_][iVoxel] >= 0)
								continue;

							points->InsertNextPoint(pTriangle->data.P[l][0], pTriangle->data.P[l][1], pTriangle->data.P[l][2]);

							iEdgePt[edgePtIdx_][iVoxel] = iPt;

							iPt++;
						}

						pTriangle = pTriangle->pNext;
					}

					if (W)
					{
						for (l = 0; l < 8; l++)
							if (W[jVoxel[l]] < 0.1f)
								break;

						if (l < 8)
						{
							mem.Clear();

							continue;
						}
					}

					pTriangle = pTriangleList->pFirst;

					while (pTriangle)
					{
						triangle = vtkSmartPointer<vtkTriangle>::New();

						for (l = 0; l < 3; l++)
						{
							edgeIdx = pTriangle->data.idx[l];

							i_ = i + dx[edgeIdx];

							if (i_ < 0)
								break;

							if (i_ > maxi)
								break;

							j_ = j + dy[edgeIdx];

							if (j_ < 0)
								break;

							if (j_ > maxj)
								break;

							k_ = k + dz[edgeIdx];

							if (k_ < 0)
								break;

							if (k_ > maxk)
								break;
						}

						if (l >= 3)
						{
							for (l = 0; l < 3; l++)
							{
								edgeIdx = pTriangle->data.idx[l];

								i_ = i + dx[edgeIdx];
								j_ = j + dy[edgeIdx];
								k_ = k + dz[edgeIdx];

								iVoxel_ = RVL3DARRAY_INDEX(f, i_, j_, k_);

								iPt_ = iEdgePt[iEdge[edgeIdx]][iVoxel_];

								triangle->GetPointIds()->SetId(l, iPt_);
							}

							//points->InsertNextPoint(pTriangle->data.P[0][0], pTriangle->data.P[0][1], pTriangle->data.P[0][2]);
							//points->InsertNextPoint(pTriangle->data.P[1][0], pTriangle->data.P[1][1], pTriangle->data.P[1][2]);
							//points->InsertNextPoint(pTriangle->data.P[2][0], pTriangle->data.P[2][1], pTriangle->data.P[2][2]);

							//triangle = vtkSmartPointer<vtkTriangle>::New();
							//triangle->GetPointIds()->SetId(0, 3 * iTriangle);
							//triangle->GetPointIds()->SetId(1, 3 * iTriangle + 1);
							//triangle->GetPointIds()->SetId(2, 3 * iTriangle + 2);

							triangles->InsertNextCell(triangle);

							iTriangle++;
						}

						pTriangle = pTriangle->pNext;
					}	// for every triangle in pTriangleList

					mem.Clear();
				}	// for every voxel

		printf("no. of pts. = %d\n", points->GetNumberOfPoints());

		printf("no. of triangles = %d\n", triangles->GetNumberOfCells());

		// Create a polydata object
		vtkSmartPointer<vtkPolyData> polyData =
			vtkSmartPointer<vtkPolyData>::New();

		// Add the geometry and topology to the polydata
		polyData->SetPoints(points);
		polyData->SetPolys(triangles);

		delete[] iEdgePt[0];
		delete[] iEdgePt[1];
		delete[] iEdgePt[2];

		return polyData;
	}
#endif

	void RandomColors(
		unsigned char *SelectionColor,
		unsigned char *&colorArray,
		int n)
	{
		int SelectionColor_[3];

		RVLCONVTOINT3(SelectionColor, SelectionColor_);

		colorArray = new unsigned char[3 * n];

		int iNode;
		int Color[3], dColor[3];
		unsigned char *NodeColor_;

		for (iNode = 0; iNode < n; iNode++)
		{
			do
			{
				Color[0] = rand() % 256;
				Color[1] = rand() % 256;
				Color[2] = rand() % 256;

				RVLDIF3VECTORS(Color, SelectionColor, dColor);
			} while (RVLDOTPRODUCT3(dColor, dColor) < 128 * 128);

			NodeColor_ = colorArray + 3 * iNode;

			NodeColor_[0] = (unsigned char)Color[0];
			NodeColor_[1] = (unsigned char)Color[1];
			NodeColor_[2] = (unsigned char)Color[2];
		}
	}

	// Remove the identical function from PlanarSurfelDetector class.

	void RandomIndices(Array<int> &A)
	{
#ifdef RVLPLANARSURFELDETECTOR_PSEUDO_RANDOM_DEBUG
		FILE *fp = fopen("..\\pseudorandom1000000.dat", "rb");

		int *iRnd = new int[A.n];

		//for (int i = 0; i < 1000000; i++)
		//	iRnd[i] = (rand() % 0x100) + (rand() % 0x100) * 0x100 + (rand() % 0x100) * 0x10000 + (rand() % 0x80) * 0x1000000;

		//fwrite(iRnd, sizeof(int), 1000000, fp);

		fread(iRnd, sizeof(int), A.n, fp);

		fclose(fp);

		int *piRnd = iRnd;
#endif

		A.Element = new int[A.n];

		int iPt;

		for (iPt = 0; iPt < A.n; iPt++)
			A.Element[iPt] = iPt;

		int iPt_;
		int iTmp;

		//srand(time(NULL)); //VIDOVIC RANDOM TEST

		for (iPt = 0; iPt < A.n; iPt++)
		{
#ifdef RVLPLANARSURFELDETECTOR_PSEUDO_RANDOM_DEBUG
			iPt_ = (*(piRnd++)) % A.n;
#else
			iPt_ = rand() % A.n;
#endif

			iTmp = A.Element[iPt];
			A.Element[iPt] = A.Element[iPt_];
			A.Element[iPt_] = iTmp;
		}

#ifdef RVLPLANARSURFELDETECTOR_PSEUDO_RANDOM_DEBUG
		delete[] iRnd;
#endif
	}

	void DistributionFromCovMx(
		float *C,
		float *R,
		float *var)
	{
		Eigen::EigenSolver<Eigen::Matrix3f> eigenSolver;

		eigenSolver.compute(Eigen::Map<Eigen::Matrix3f>(C));

		Eigen::Matrix3f R_ = eigenSolver.pseudoEigenvectors();

		R[0] = R_(0, 0);
		R[1] = R_(1, 0);
		R[2] = R_(2, 0);
		R[3] = R_(0, 1);
		R[4] = R_(1, 1);
		R[5] = R_(2, 1);

		float *X = R;
		float *Y = R + 3;
		float *Z = R + 6;

		RVLCROSSPRODUCT3(X, Y, Z);

		Eigen::Vector3cf var_ = eigenSolver.eigenvalues();

		var[0] = var_[0].real();
		var[1] = var_[1].real();
		var[2] = var_[2].real();
	}

	char *ReadConfigurationFile(char *cfgSelectionFileName)
	{
		char line[500];

		FILE *fp = fopen(cfgSelectionFileName, "r");

		char *cfgFileName = NULL;
		int linelen;

		while (!feof(fp))
		{
			fgets(line, 500, fp);

			if (line[0] == '%')
				continue;

			linelen = strlen(line);

			if (line[linelen - 1] == 10)
				line[linelen - 1] = 0;

			cfgFileName = RVLCreateString(line);
		}

		fclose(fp);

		return cfgFileName;
	}

	void MeanShift1D(
		Array<int> histogram,
		int winSize,
		int minClusterSize,
		Array<int> &clusters,
		int *assignment,
		int *wAgg,
		int *move,
		int *w)
	{
		int halfWinSize = (winSize - 1) / 2;

		if (clusters.Element == NULL)
			clusters.Element = new int[histogram.n];

		if (assignment == NULL)
			assignment = new int[histogram.n];

		if (wAgg == NULL)
			wAgg = new int[histogram.n];

		bool bAllocateMove = (move == NULL);

		if (bAllocateMove)
			move = new int[histogram.n];

		bool bAllocatew = (w == NULL);

		if (bAllocatew)
			w = new int[histogram.n];

		int i, j, k, move_, w_;

		for (i = 0; i < histogram.n; i++)
		{
			w_ = 0;
			move_ = 0;

			for (j = -halfWinSize; j <= halfWinSize; j++)
			{
				k = ((i + j + histogram.n) % histogram.n);

				move_ += ((j + halfWinSize) * histogram.Element[k]);

				w_ += histogram.Element[k];
			}

			move_ = (w_ > 0 ? (2 * move_ + w_) / (2 * w_) - halfWinSize : 0);

			move[i] = move_;

			w[i] = w_;
		}

		memset(wAgg, 0, histogram.n * sizeof(int));

		int sign;

		for (i = 0; i < histogram.n; i++)
		{
			if (w[i] == 0)
			{
				assignment[i] = -1;

				continue;
			}

			sign = (move[i] >= 0 ? 1 : -1);

			j = i;

			while (sign * move[j] > 0)
				j = (j + move[j] + histogram.n) % histogram.n;

			if (move[j] < 0)
				j = (j + move[j] + histogram.n) % histogram.n;

			wAgg[j] += histogram.Element[i];

			assignment[i] = j;
		}

		clusters.n = 0;

		for (i = 0; i < histogram.n; i++)
			if (wAgg[i] >= minClusterSize)
				clusters.Element[clusters.n++] = i;

		if (bAllocateMove)
			delete[] move;

		if (bAllocatew)
			delete[] w;
	}

	void CreateImage3x3NeighborhoodLT(
		int w,
		int *neighbor)
	{
		neighbor[0] = -1 - w;
		neighbor[1] = -w;
		neighbor[2] = 1 - w;
		neighbor[3] = -1;
		neighbor[4] = 0;
		neighbor[5] = 1;
		neighbor[6] = -1 + w;
		neighbor[7] = w;
		neighbor[8] = 1 + w;
	}

	void CreateGrayScaleImage(Array2D<float> inputImage, cv::Mat& outputImage)
	{
		cv::Mat inputImage_(inputImage.h, inputImage.w, CV_32FC1, inputImage.Element);

		double minI, maxI;

		cv::minMaxLoc(inputImage_, &minI, &maxI);

		float range = (float)(maxI - minI);

		inputImage_.convertTo(outputImage, CV_8U, 255.0 / range, -255.0 * minI / range);
	}

	//Vidovic
	void UnionOfIndices(
		Array<int> &iInArray1,
		Array<int> &iInArray2,
		Array<int> &iOutArray,
		bool *bIndicesInArray)
	{
		iOutArray.n = 0;
		int iVertex, i;

		//copy from iInArray1
		for (i = 0; i < iInArray1.n; i++)
		{
			iVertex = iInArray1.Element[i];

			if (bIndicesInArray[iVertex])
				continue;

			iOutArray.Element[iOutArray.n++] = iVertex;

			bIndicesInArray[iVertex] = true;
		}

		//copy from iInArray2
		for (i = 0; i < iInArray2.n; i++)
		{
			iVertex = iInArray2.Element[i];

			if (bIndicesInArray[iVertex])
				continue;

			iOutArray.Element[iOutArray.n++] = iVertex;

			bIndicesInArray[iVertex] = true;
		}

		for (i = 0; i < iOutArray.n; i++)
			bIndicesInArray[iOutArray.Element[i]] = false;
	}

	bool CheckFlag(unsigned char flags, unsigned char flagToCheck)
	{
		return flags & flagToCheck;
	}

	bool CheckFlags(unsigned char flags, unsigned char flagsToCheck)
	{
		return flags == flagsToCheck;
	}
	//End Vidovic
}	// namespace RVL

void FilterImage(cv::Mat img)
{
	cv::Mat newImg(480, 640, CV_16UC1, cv::Scalar::all(0));
	img.copyTo(newImg);
	float sum = 0;
	float max = 0;
	int no = 0;
	for (int y = 10; y < (img.rows - 10); y++)
	{
		for (int x = 10; x < (img.cols - 10); x++)
		{
			if (img.at<uint16_t>(y, x) > 0)
				continue;
			//inner 
			sum = 0;
			no = 0;
			max = 0;
			for (int v = -1; v < 1; v++)
			{
				for (int u = -1; u < 1; u++)
				{
					if (img.at<uint16_t>(y + v, x + u) == 0)
						continue;
					sum += img.at<uint16_t>(y + v, x + u);
					no++;
					if (img.at<uint16_t>(y + v, x + u) > max)
						max = img.at<uint16_t>(y + v, x + u);
				}
			}
			if (no != 0)
				newImg.at<uint16_t>(y, x) = max;// sum / no;
		}
	}
	newImg.copyTo(img);
}

